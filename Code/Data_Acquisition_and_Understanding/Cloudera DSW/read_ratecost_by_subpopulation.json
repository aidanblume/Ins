[
{
  "pk": 22886, 
  "model": "desktop.document2", 
  "fields": {
    "search": "select \n    product_code\n    , segment\n    , source_table\n    , 30d_readmit\n    , count(*)\n    , sum(paid_amt_case)\nfrom nathalie.demographics_added\n--where adm_age > 17\n--and adm_age < 65\ngroup by product_code, segment, source_table, 30d_readmit\norder by product_code, segment, source_table, 30d_readmit", 
    "uuid": "86dc0fd4-4e43-2a54-36cf-70c4b1b42332", 
    "extra": "", 
    "type": "query-impala", 
    "description": "readmission rate and cost subpopulation contrast", 
    "is_history": false, 
    "parent_directory": [
      "57c6b61d-2712-48a6-9e48-11e758e2cdce", 
      1, 
      false
    ], 
    "is_managed": false, 
    "last_modified": "2018-04-16T15:13:27.514", 
    "version": 1, 
    "owner": [
      "nathalieb"
    ], 
    "dependencies": [], 
    "data": "{\"loadingHistory\": false, \"schedulerViewModel\": null, \"retryModalCancel\": null, \"schedulerViewModelIsLoaded\": false, \"historyTotalPages\": 6, \"unloaded\": false, \"id\": 22886, \"retryModalConfirm\": null, \"uuid\": \"4734a1c3-dc2d-476c-aeb2-ffdb32d05e9d\", \"onSuccessUrl\": null, \"is_history\": false, \"historyFilterVisible\": false, \"snippets\": [{\"wasBatchExecuted\": false, \"chartLimits\": [5, 10, 25, 50, 100], \"associatedDocumentLoading\": true, \"isReady\": true, \"statement_raw\": \"/***\\n20180414\\n***/\\n\\n/*\\nUNIQUE_CASES\\n--Select all unique cases across QNXT, CLM and ENC, deduplicating with priority QNXT>CLM>ENC. \\n--Join with MEMMO information about LOB\\n--Contains on separate rows nitial admits and transfers (continuous stays). These will be unified into single stays on a subsequent step.\\n--Top-level select has : row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\n*/\\n/*\\ncreate table NATHALIE.NJB_UNIQUE_CASES \\nas\\nselect \\n    case_id, adm_dt, dis_dt, UNIQUE_CASES.cin_no, member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n    , cur_pcp, cur_site_no, product_code, segment, yearmth\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom\\n(--select unique tupple (member_no, admi_dt, dis_dt) tupple with priority QNXT>CLM>ENC\\n    select *\\n    from\\n    ( --add number rows inside partitions where each partition is a unique (member_no, admi_dt, dis_dt) tupple\\n        select case_id, adm_dt, dis_dt, cin_no, member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n        , row_number() over(partition by member_no, adm_dt, dis_dt order by source_table asc, case_id desc) as rownumber\\n        from\\n        ( -- union of cases across 3 data tables: qnxt, clm, enc\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, paid_amt_case\\n            , 1 as source_table\\n            --from `hoap`.`tmp_QNXT_CASE_INPSNF`\\n            from `hoap`.`QNXT_CASE_INPSNF`\\n            union\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, paid_amt_case\\n            , 2 as source_table\\n            --from `hoap`.`tmp_clm_case_inpsnf`\\n            from `hoap`.`clm_case_inpsnf`\\n            union\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, null as paid_amt_case\\n            , 3 as source_table\\n            --from `hoap`.`tmp_ENC_CASE_INPSNF`\\n            from `hoap`.`ENC_CASE_INPSNF`\\n        ) AS ALL_CASES\\n        order by member_no, adm_dt, dis_dt\\n    ) ALL_CASES_PARTITIONED\\n    where rownumber =  1\\n) as UNIQUE_CASES  \\nleft join\\n( -- member information from MEMMO table\\n    select cin_no, cur_pcp, cur_site_no, product_code, segment, yearmth\\n    from \\n    ( -- rank identical cin_no by recncy in order to unique rows by cin_no\\n        select cin_no, pcp as cur_pcp, site_no as cur_site_no, product_code, segment, yearmth\\n        , row_number() over(partition by cin_no order by yearmth desc) as rownumber\\n        --from `HOAP`.`tmp_memmo`\\n        from `HOAP`.`memmo`\\n    ) as M\\n    where rownumber = 1\\n) as MEMMO\\non UNIQUE_CASES.cin_no = MEMMO.cin_no\\n;\\n*/\\n\\n                /*\\n                SYNTHETIC DATA \\n                */\\n                /*\\n                create view nathalie.njb_synthetic_unique_cases as\\n                select\\n                    case_id\\n                    , case \\n                        when (digit in (0, 5)) then cast('2017-06-01' as timestamp)\\n                        when (digit in (1, 6)) then cast('2017-06-06' as timestamp)\\n                        when (digit in (2, 7)) then cast('2017-06-11' as timestamp)\\n                        when (digit in (3, 8)) then cast('2017-06-21' as timestamp)\\n                        else cast('2017-06-26' as timestamp)\\n                      end as adm_dt\\n                    , case \\n                        when (digit in (0, 5)) then cast('2017-06-05' as timestamp)\\n                        when (digit in (1, 6)) then cast('2017-06-08' as timestamp)\\n                        when (digit in (2, 7)) then cast('2017-06-20' as timestamp)\\n                        when (digit in (3, 8)) then cast('2017-06-21' as timestamp)\\n                        else cast('2017-07-15' as timestamp)\\n                      end as dis_dt\\n                    , cin_no, member_no\\n                    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n                    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n                    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n                    , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n                    , cur_pcp, cur_site_no, product_code, segment, yearmth\\n                    , rownumber\\n                    , digit\\n                from\\n                (\\n                    select\\n                        case_id\\n                        , cin_no, member_no\\n                        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n                        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n                        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n                        , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n                        , cur_pcp, cur_site_no, product_code, segment, yearmth\\n                        , rownumber\\n                        --, digit = right(rownumber, 1)\\n                        , case \\n                            when rownumber < 10 then rownumber\\n                            when rownumber between 10 and 99 then cast(substring(cast(rownumber as varchar(10)), 2, 1) as int) \\n                            else cast(substring(cast(rownumber as varchar(10)), 2, 1) as int) \\n                          end as digit\\n                    from nathalie.njb_unique_cases\\n                    limit 100\\n                ) as Subquery\\n                ;\\n                */\\n\\n/*\\nABSORB_TRANSFERS ---> no loop\\n--\\nON THE SUBJECT OF LOOPS: \\nImpala does not support any loop syntax (see https://stackoverflow.com/questions/49523380/write-a-while-loop-in-impala-sql)\\nTherefore as long as you need to fuse admits, you need to manually repeat the search-and-fuse script below. \\n*/\\n/*\\nThe following is alsways the 1st step and is only run one time\\n*/\\ncreate table njb_complete_cases_1\\nas\\nselect *\\nfrom\\n(    \\n    select \\n        case_id\\n        , adm_dt\\n        , dis_dt\\n        , cin_no\\n        , member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity\\n        , aprdrg\\n        , dis_status\\n        , provider\\n        , cur_pcp\\n        , cur_site_no\\n        , product_code\\n        , segment\\n        , yearmth\\n        , source_table\\n        , stay_interval\\n        , paid_amt_case\\n        , row_number() over(partition by member_no, dis_dt order by adm_dt asc) as rownumber --order newly engineered cases above cases that are transfers and whose admit date is later\\n    from\\n    ( -- DIS_DT_UPDATED // use stay_interval to compute new discharge date\\n        select \\n            case \\n                when stay_interval < 2 then ss_case_id\\n                else fs_case_id\\n            end as case_id\\n            , adm_dt\\n            ,   case\\n                    when stay_interval < 2 then ss_dis_dt\\n                    else fs_dis_dt\\n                end as dis_dt\\n            , cin_no\\n            , member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity\\n            , aprdrg\\n            , dis_status\\n            , provider\\n            , cur_pcp\\n            , cur_site_no\\n            , product_code\\n            , segment\\n            , yearmth\\n            , case\\n                when stay_interval < 2 then concat(fs_source_table, ss_source_table)\\n                else fs_source_table\\n            end as source_table\\n            , stay_interval\\n            , case\\n                when (stay_interval < 2 and fs_case_id != ss_case_id) then fs_paid_amt_case + ss_paid_amt_case\\n                else fs_paid_amt_case\\n            end as paid_amt_case\\n        from\\n        ( --'INTERVAL_ADDED' // add interval between 1st discharge date and 2nd admit date to create subquery called 'interval_added'\\n            select --select with priority QNXT > CLM > ENC and join with MEMMO data\\n                FS.case_id as fs_case_id, FS.adm_dt, FS.dis_dt as fs_dis_dt, FS.cin_no, FS.member_no\\n                , FS.case_dx1, FS.case_dx2, FS.case_dx3, FS.case_dx4, FS.case_dx5, FS.case_dx6, FS.case_dx7, FS.case_dx8, FS.case_dx9, FS.case_dx10\\n                , FS.case_dx11, FS.case_dx12, FS.case_dx13, FS.case_dx14, FS.case_dx15, FS.case_dx16, FS.case_dx17, FS.case_dx18, FS.case_dx19, FS.case_dx20 \\n                , FS.case_pr1, FS.case_pr2, FS.case_pr3, FS.case_pr4, FS.case_pr5, FS.case_pr6, FS.case_pr7, FS.case_pr8, FS.case_pr9, FS.case_pr10\\n                , FS.severity, FS.aprdrg, FS.dis_status, FS.provider\\n                , FS.cur_pcp, FS.cur_site_no, FS.product_code, FS.segment, FS.yearmth\\n                --, RIGHT('00' + CONVERT(VARCHAR, FS.source_table), 2) as fs_source_table\\n                , cast(FS.source_table as varchar(1)) as fs_source_table\\n                , SS.dis_dt as ss_dis_dt\\n                , concat(cast(FS.source_table as varchar(1)), ', ', cast(SS.source_table as varchar(1))) as ss_source_table\\n                , concat(FS.case_id, ', ', SS.case_id) as ss_case_id\\n                , case\\n                    when FS.member_no = SS.member_no \\n                        then abs(datediff(SS.adm_dt, FS.dis_dt)) -- absolute value selected bc w/ synthetic data, datediff under 1 month were neg, over 1 month pos --> did not find cause but this step appeared to be necessary for correct output\\n                        else null\\n                    end as stay_interval\\n                , FS.paid_amt_case as fs_paid_amt_case\\n                , SS.paid_amt_case as ss_paid_amt_case\\n            from\\n            NATHALIE.NJB_UNIQUE_CASES as FS --TK NEED TO SWITCH OUT OF SYNTHETIC DATA FOR ACTUAL QUERY\\n            --NATHALIE.njb_synthetic_UNIQUE_CASES as FS\\n            --order by UNIQUE_CASES.rownumber\\n            inner join\\n            NATHALIE.NJB_UNIQUE_CASES as SS --TK NEED TO SWITCH OUT OF SYNTHETIC DATA FOR ACTUAL QUERY\\n            --NATHALIE.njb_synthetic_UNIQUE_CASES as SS\\n            --order by UNIQUE_CASES.rownumber\\n            ON SS.rownumber = FS.rownumber + 1\\n        ) AS INTERVAL_ADDED\\n    ) AS DIS_DT_UPDATED\\n) AS ROWNUMER_ADDED\\nwhere rownumber = 1\\n;\\n/* add rownumber to the final product -- may not be necessary after you've written the loop \\n*/\\ncreate table NATHALIE.njb_complete_cases_2 as\\nselect \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , paid_amt_case\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom NATHALIE.njb_complete_cases_1\\n;\\n\\n/* count rows to see whether subsequent counts become lower */\\nselect count(*) from  njb_complete_cases_2;\\n--ANS:1,272,272\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/*\\nMANUALLY CONTROLLED LOOP\\nStart with table name: njb_complete_cases_2\\nHas columns: \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , paid_amt_case\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\n\\nTransformation: join with offset = 1, look for transfers, incorporate transfer dates and costs to 1 admission, delete transfer and renumber rows. \\n\\nEnd with table name njb_complete_case; has same columns as above\\n*/\\n\\n--create table nathalie.njb_complete_cases_3 \\ncreate table nathalie.njb_complete_cases_5\\nas\\nselect *\\nfrom\\n(    \\n    select \\n        case_id\\n        , adm_dt\\n        , dis_dt\\n        , cin_no\\n        , member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity\\n        , aprdrg\\n        , dis_status\\n        , provider\\n        , cur_pcp\\n        , cur_site_no\\n        , product_code\\n        , segment\\n        , yearmth\\n        , source_table\\n        , stay_interval\\n        , paid_amt_case\\n        , row_number() over(partition by member_no, dis_dt order by adm_dt asc) as rownumber --order newly engineered cases above cases that are transfers and whose admit date is later\\n    from\\n    ( -- DIS_DT_UPDATED // use stay_interval to compute new discharge date\\n        select \\n            case \\n                when stay_interval < 2 then ss_case_id\\n                else fs_case_id\\n            end as case_id\\n            , adm_dt\\n            ,   case\\n                    when stay_interval < 2 then ss_dis_dt\\n                    else fs_dis_dt\\n                end as dis_dt\\n            , cin_no\\n            , member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity\\n            , aprdrg\\n            , dis_status\\n            , provider\\n            , cur_pcp\\n            , cur_site_no\\n            , product_code\\n            , segment\\n            , yearmth\\n            , case\\n                when stay_interval < 2 then concat(fs_source_table, ss_source_table)\\n                else fs_source_table\\n            end as source_table\\n            , stay_interval\\n            , case\\n                when (stay_interval < 2 and fs_case_id != ss_case_id) then fs_paid_amt_case + ss_paid_amt_case \\n                else fs_paid_amt_case\\n            end as paid_amt_case\\n        from\\n        ( --'INTERVAL_ADDED' // add interval between 1st discharge date and 2nd admit date to create subquery called 'interval_added'\\n            select --select with priority QNXT > CLM > ENC and join with MEMMO data\\n                FS.case_id as fs_case_id, FS.adm_dt, FS.dis_dt as fs_dis_dt, FS.cin_no, FS.member_no\\n                , FS.case_dx1, FS.case_dx2, FS.case_dx3, FS.case_dx4, FS.case_dx5, FS.case_dx6, FS.case_dx7, FS.case_dx8, FS.case_dx9, FS.case_dx10\\n                , FS.case_dx11, FS.case_dx12, FS.case_dx13, FS.case_dx14, FS.case_dx15, FS.case_dx16, FS.case_dx17, FS.case_dx18, FS.case_dx19, FS.case_dx20 \\n                , FS.case_pr1, FS.case_pr2, FS.case_pr3, FS.case_pr4, FS.case_pr5, FS.case_pr6, FS.case_pr7, FS.case_pr8, FS.case_pr9, FS.case_pr10\\n                , FS.severity, FS.aprdrg, FS.dis_status, FS.provider\\n                , FS.cur_pcp, FS.cur_site_no, FS.product_code, FS.segment, FS.yearmth\\n                , cast(FS.source_table as varchar(1)) as fs_source_table\\n                , SS.dis_dt as ss_dis_dt\\n                , concat(cast(FS.source_table as varchar(1)), ', ', cast(SS.source_table as varchar(1))) as ss_source_table\\n                , concat(FS.case_id, ', ', SS.case_id) as ss_case_id\\n                , case\\n                    when FS.member_no = SS.member_no \\n                        then abs(datediff(SS.adm_dt, FS.dis_dt))\\n                        else null\\n                    end as stay_interval\\n                , FS.paid_amt_case as fs_paid_amt_case\\n                , SS.paid_amt_case as ss_paid_amt_case\\n            from\\n            --NATHALIE.NJB_COMPLETE_CASES_2 as FS \\n            NATHALIE.NJB_COMPLETE_CASES_4 as FS \\n            inner join\\n            --NATHALIE.NJB_COMPLETE_CASES_2 as SS\\n            NATHALIE.NJB_COMPLETE_CASES_4 as SS\\n            ON SS.rownumber = FS.rownumber + 1\\n        ) AS INTERVAL_ADDED\\n    ) AS DIS_DT_UPDATED\\n) AS ROWNUMER_ADDED\\nwhere rownumber = 1\\n;\\n/* add rownumber to the final product -- may not be necessary after you've written the loop \\n*/\\n--create table NATHALIE.njb_complete_cases_4 as\\ncreate table NATHALIE.njb_complete_cases_6 as\\nselect \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , paid_amt_case\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom NATHALIE.njb_complete_cases_5\\n--from NATHALIE.njb_complete_cases_7\\n;\\n\\n/* count rows to see whether subsequent counts become lower */\\n--select count(*) from  njb_complete_cases_4;\\nselect count(*) from  njb_complete_cases_6;\\n--ANS:1,272,272; 1,270,709; 1,270,693; 1270692; [se e 'last row' issue\\n--~to v6\\n\\n/*\\nSave the last iteration\\n*/\\ncreate table nathalie.njb_transfers_absorbed\\nas\\nselect *\\nfrom njb_complete_cases_6\\n;\\n\\n/*\\nNEXT STEP... \\nTake product of last step which gives you truly unique hospitatizations and label readmits + compute subpop stats...\\n*/\\n\\n/*\\nLABELED OUTCOME\\n--Compute labeled outcome: readmit in 30 d, or no readmit (2), or death in 30 days\\n--look for contiguous admits by juxtaposing a row with the row that follows it and taking a datedif between discharge and admit. Flag as contiguous stay (1) all with datedif < 2. \\n--need to repeat until longest continuous stay is isolated.\\n--TK !!! pad the 1st and last rows of 2 versions of NATHALIE.NJB_[input name]. This will help with the next step where the tables are joined by an offset row number.\\n*/\\ndrop view nathalie.njb_cases_with_labelled_outcomes;\\n\\ncreate table NATHALIE.njb_cases_with_labelled_outcomes as\\nSELECT \\n    case_id\\n    , a_dis_dt -- spot check\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , a_member_no -- spot check\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , rownumber\\n    , days_since_prior_discharge\\n    , prior_stay_case_id\\n    , case\\n        when days_since_prior_discharge <= 30 then 1 \\n        else 0 \\n      end as 30d_readmit\\n    , paid_amt_case\\nFROM\\n(\\n\\tSELECT \\n    \\t  B.case_id\\n        , A.dis_dt as a_dis_dt -- spot check\\n        , B.adm_dt\\n        , B.dis_dt\\n        , B.cin_no\\n        , B.member_no\\n        , A.member_no as a_member_no -- spot check\\n        , B.case_dx1, B.case_dx2, B.case_dx3, B.case_dx4, B.case_dx5, B.case_dx6, B.case_dx7, B.case_dx8, B.case_dx9, B.case_dx10\\n        , B.case_dx11, B.case_dx12, B.case_dx13, B.case_dx14, B.case_dx15, B.case_dx16, B.case_dx17, B.case_dx18, B.case_dx19, B.case_dx20 \\n        , B.case_pr1, B.case_pr2, B.case_pr3, B.case_pr4, B.case_pr5, B.case_pr6, B.case_pr7, B.case_pr8, B.case_pr9, B.case_pr10\\n        , B.severity\\n        , B.aprdrg\\n        , B.dis_status\\n        , B.provider\\n        , B.cur_pcp\\n        , B.cur_site_no\\n        , B.product_code\\n        , B.segment\\n        , B.yearmth\\n        , B.source_table\\n        , B.stay_interval\\n        , B.paid_amt_case\\n        , B.rownumber\\n    \\t, CASE\\n        \\t\\tWHEN A.member_no = B.member_no THEN ABS(DATEDIFF(A.dis_dt, B.adm_dt))\\n        \\t\\tELSE NULL\\n    \\t    END AS days_since_prior_discharge\\n    \\t, case\\n        \\t    when A.member_no = B.member_no then A.case_id\\n        \\t    else null\\n        \\tend as prior_stay_case_id\\n    FROM NATHALIE.njb_transfers_absorbed AS B LEFT JOIN NATHALIE.njb_transfers_absorbed AS A ON B.rownumber = A.rownumber + 1\\n) AS S\\n;\\n\\n\\n/*\\nBRING IN THE DEMOGRAPHICS\\n*/\\n\\n/*\\n    adm_dt\\n    , dis_dt\\n    , A.cin_no\\n    , A.member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , days_since_prior_discharge\\n    , case_id\\n    , prior_stay_case_id\\n    , 30d_readmit\\n    , paid_amt_case\\n    , dob\\n    , abs(datediff(dob, adm_dt)) as adm_age\\n    , gender\\n    , language_written_code\\n    , ethnicity_code\\n    , zip_code\\n    , zip4\\n    , deathdate\\n*/\\n\\ncreate table nathalie.demographics_added\\nas\\nselect \\n    adm_dt\\n    , dis_dt\\n    , A.cin_no\\n    , A.member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , A.product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , days_since_prior_discharge\\n    , case_id\\n    , prior_stay_case_id\\n    , 30d_readmit\\n    , paid_amt_case\\n    , dob\\n    , abs(datediff(dob, adm_dt)) as adm_age\\n    , gender\\n    , language_written_code\\n    , ethnicity_code\\n    , zip_code\\n    , zip4\\n    , deathdate\\nfrom nathalie.njb_cases_with_labelled_outcomes as A left join hoap.members as B on A.cin_no = B.cin_no\\n;\\n\\n\\n/*\\nLABEL THE LOBs and ENGINEER NEW NAMES (concatenate 10 + segment)\\n*/\\n\\n/*\\nTABULATE BY POPULATION\\nTK do you have the segmentation info you need?\\n-- LOB (eg CMC) Y\\n-- segment (eg SPD) Y\\n-- ??? Dx (HF, COPD, etc.) Y [but: across many fields; I may need to select a small number of the most common ones, and see rates and costs there)\\n-- ??? Age group (use C, TAY, A, S) --> Need to create a field for this\\n-- NEED TO COMPUTE Y: readmission rate is calculable in Excel (or in group by's); \\nAlso need count of admits, readmits, readmit cost exists in each segment [note here that what I cannot capture is opportunity for intervention vs. readmit will happen any way bc of illness type; see maybe success in applying TOC --> do such analyses exist contrasting dif. Dx?)\\n*/\\n\\nselect \\n    product_code\\n    , segment\\n    , source_table\\n    , 30d_readmit\\n    , count(*)\\n    , sum(paid_amt_case)\\nfrom nathalie.demographics_added\\n--where adm_age > 17\\n--and adm_age < 65\\ngroup by product_code, segment, source_table, 30d_readmit\\norder by product_code, segment, source_table, 30d_readmit\\n;\\n\\n\\n\\n\\n\\n/*\\nREMAINING ISSUES\\n*/\\n--TK READMISSIONS ALL 0 --> check that you use 'abs' in the readmission computation\\n--TK source tables are not comma delimeted. Also, recode so boolean by 1, 2, 3? Would loose sequence information.\\n--TK to address last row: you are loosing the last row each iteration. BRING IT BACK! --TK !!! pad the 1st and last rows of 2 versions of NATHALIE.NJB_[input name]. This will help with the next step where the tables are joined by an offset row number.\\n--TK to address H vs SNF --> how did you separate these & are you sure you did it correctly? -- TKTK Hospital (whatever is there, include counts) --'provider' but verify that this captures the hospitals. \\n--TK bring in DOB, DOD and other demographics -- SCREENING: death date -- SCREENING: birth date\\n-- TKTK age group (use C, TAY, A, S) -- TK I CANNOT FIND DOB IN THESE FILES. Ingest 'members' table? Get from QNXT?\\n\\n\\n\\n\\n\\n\\n\", \"statusForButtons\": \"executed\", \"showLogs\": false, \"variableNames\": [], \"associatedDocumentUuid\": null, \"compatibilitySourcePlatform\": \"impala\", \"chartLimit\": null, \"progress\": 0, \"chartType\": \"bars\", \"isFetchingData\": false, \"name\": \"\", \"statementTypes\": [\"text\", \"file\"], \"is_redacted\": false, \"currentQueryTab\": \"queryResults\", \"chartScope\": \"world\", \"result\": {\"statement_id\": 0, \"isMetaFilterVisible\": false, \"meta\": [], \"logLines\": 1, \"id\": \"106a4b3e-049c-5c19-c217-0e7fd4e7e121\", \"logs\": \"\", \"statements_count\": 1, \"rows\": 82, \"hasSomeResults\": true, \"filteredMetaChecked\": true, \"hasMore\": false, \"filteredMeta\": [{\"comment\": null, \"checked\": true, \"name\": \"product_code\", \"originalIndex\": 1, \"cssClass\": \"sort-string\", \"type\": \"STRING_TYPE\"}, {\"comment\": null, \"checked\": true, \"name\": \"segment\", \"originalIndex\": 2, \"cssClass\": \"sort-string\", \"type\": \"STRING_TYPE\"}, {\"comment\": null, \"checked\": true, \"name\": \"source_table\", \"originalIndex\": 3, \"cssClass\": \"sort-string\", \"type\": \"STRING_TYPE\"}, {\"comment\": null, \"checked\": true, \"name\": \"30d_readmit\", \"originalIndex\": 4, \"cssClass\": \"sort-numeric\", \"type\": \"TINYINT_TYPE\"}, {\"comment\": null, \"checked\": true, \"name\": \"count(*)\", \"originalIndex\": 5, \"cssClass\": \"sort-numeric\", \"type\": \"BIGINT_TYPE\"}, {\"comment\": null, \"checked\": true, \"name\": \"sum(paid_amt_case)\", \"originalIndex\": 6, \"cssClass\": \"sort-numeric\", \"type\": \"DOUBLE_TYPE\"}], \"type\": \"table\", \"handle\": {\"log_context\": null, \"statements_count\": 1, \"end\": {\"column\": 304, \"row\": 0}, \"statement_id\": 0, \"has_more_statements\": false, \"start\": {\"column\": 0, \"row\": 0}, \"secret\": \"BAQWWnNlTv0AAAAA2Df9AA==\\n\", \"has_result_set\": true, \"session_guid\": \"sD3uO4TXRlyHacDkDiPjNA==\\n\", \"statement\": \"select \\n    product_code\\n    , segment\\n    , source_table\\n    , 30d_readmit\\n    , count(*)\\n    , sum(paid_amt_case)\\nfrom nathalie.demographics_added\\n--where adm_age > 17\\n--and adm_age < 65\\ngroup by product_code, segment, source_table, 30d_readmit\\norder by product_code, segment, source_table, 30d_readmit\", \"operation_type\": 0, \"modified_row_count\": null, \"guid\": \"BAQWWnNlTv0AAAAA2Df9AA==\\n\", \"previous_statement_hash\": \"f8095ed0f5ff2ab38f69571d585e56d3268713256295fbe2c38f4bc2\"}, \"metaFilter\": \"\", \"explanation\": \"\", \"statement_range\": {\"start\": {\"column\": 0, \"row\": 0}, \"end\": {\"column\": 0, \"row\": 0}}, \"startTime\": \"2018-04-16T22:12:13.605Z\", \"data\": [], \"executionTime\": 4821, \"fetchedOnce\": false, \"hasResultset\": true, \"endTime\": \"2018-04-16T22:12:18.426Z\"}, \"ddlNotification\": 0.19689942156066298, \"errors\": [], \"chartMapHeat\": null, \"compatibilitySourcePlatforms\": [{\"name\": \"Teradata\", \"value\": \"teradata\"}, {\"name\": \"Oracle\", \"value\": \"oracle\"}, {\"name\": \"Netezza\", \"value\": \"netezza\"}, {\"name\": \"Impala\", \"value\": \"impala\"}, {\"name\": \"Hive\", \"value\": \"hive\"}, {\"name\": \"DB2\", \"value\": \"db2\"}, {\"name\": \"Greenplum\", \"value\": \"greenplum\"}, {\"name\": \"MySQL\", \"value\": \"mysql\"}, {\"name\": \"PostgreSQL\", \"value\": \"postgresql\"}, {\"name\": \"Informix\", \"value\": \"informix\"}, {\"name\": \"SQL Server\", \"value\": \"sqlserver\"}, {\"name\": \"Sybase\", \"value\": \"sybase\"}, {\"name\": \"Access\", \"value\": \"access\"}, {\"name\": \"Firebird\", \"value\": \"firebird\"}, {\"name\": \"ANSISQL\", \"value\": \"ansisql\"}, {\"name\": \"Generic\", \"value\": \"generic\"}], \"aceErrorsHolder\": [], \"showOptimizer\": false, \"compatibilityTargetPlatform\": \"impala\", \"jobs\": [], \"statementType\": \"text\", \"variableValues\": {}, \"isCanceling\": false, \"queriesTotalPages\": 1, \"formatEnabled\": true, \"properties\": {\"settings\": []}, \"aceErrors\": [], \"externalStatementLoaded\": false, \"chartScatterSize\": null, \"chartYSingle\": null, \"suggestion\": \"\", \"statementPath\": \"\", \"showLongOperationWarning\": false, \"chartX\": \"product_code\", \"lastExecuted\": 1523916733597, \"variables\": [], \"showChart\": false, \"isResultSettingsVisible\": false, \"showGrid\": true, \"pinnedContextTabs\": [], \"viewSettings\": {\"sqlDialect\": true, \"placeHolder\": \"Example: SELECT * FROM tablename, or press CTRL + space\"}, \"statementsList\": [\"/***\\n20180414\\n***/\\n\\n/*\\nUNIQUE_CASES\\n--Select all unique cases across QNXT, CLM and ENC, deduplicating with priority QNXT>CLM>ENC. \\n--Join with MEMMO information about LOB\\n--Contains on separate rows nitial admits and transfers (continuous stays). These will be unified into single stays on a subsequent step.\\n--Top-level select has : row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\n*/\\n/*\\ncreate table NATHALIE.NJB_UNIQUE_CASES \\nas\\nselect \\n    case_id, adm_dt, dis_dt, UNIQUE_CASES.cin_no, member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n    , cur_pcp, cur_site_no, product_code, segment, yearmth\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom\\n(--select unique tupple (member_no, admi_dt, dis_dt) tupple with priority QNXT>CLM>ENC\\n    select *\\n    from\\n    ( --add number rows inside partitions where each partition is a unique (member_no, admi_dt, dis_dt) tupple\\n        select case_id, adm_dt, dis_dt, cin_no, member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n        , row_number() over(partition by member_no, adm_dt, dis_dt order by source_table asc, case_id desc) as rownumber\\n        from\\n        ( -- union of cases across 3 data tables: qnxt, clm, enc\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, paid_amt_case\\n            , 1 as source_table\\n            --from `hoap`.`tmp_QNXT_CASE_INPSNF`\\n            from `hoap`.`QNXT_CASE_INPSNF`\\n            union\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, paid_amt_case\\n            , 2 as source_table\\n            --from `hoap`.`tmp_clm_case_inpsnf`\\n            from `hoap`.`clm_case_inpsnf`\\n            union\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, null as paid_amt_case\\n            , 3 as source_table\\n            --from `hoap`.`tmp_ENC_CASE_INPSNF`\\n            from `hoap`.`ENC_CASE_INPSNF`\\n        ) AS ALL_CASES\\n        order by member_no, adm_dt, dis_dt\\n    ) ALL_CASES_PARTITIONED\\n    where rownumber =  1\\n) as UNIQUE_CASES  \\nleft join\\n( -- member information from MEMMO table\\n    select cin_no, cur_pcp, cur_site_no, product_code, segment, yearmth\\n    from \\n    ( -- rank identical cin_no by recncy in order to unique rows by cin_no\\n        select cin_no, pcp as cur_pcp, site_no as cur_site_no, product_code, segment, yearmth\\n        , row_number() over(partition by cin_no order by yearmth desc) as rownumber\\n        --from `HOAP`.`tmp_memmo`\\n        from `HOAP`.`memmo`\\n    ) as M\\n    where rownumber = 1\\n) as MEMMO\\non UNIQUE_CASES.cin_no = MEMMO.cin_no\\n;\\n*/\\n\\n                /*\\n                SYNTHETIC DATA \\n                */\\n                /*\\n                create view nathalie.njb_synthetic_unique_cases as\\n                select\\n                    case_id\\n                    , case \\n                        when (digit in (0, 5)) then cast('2017-06-01' as timestamp)\\n                        when (digit in (1, 6)) then cast('2017-06-06' as timestamp)\\n                        when (digit in (2, 7)) then cast('2017-06-11' as timestamp)\\n                        when (digit in (3, 8)) then cast('2017-06-21' as timestamp)\\n                        else cast('2017-06-26' as timestamp)\\n                      end as adm_dt\\n                    , case \\n                        when (digit in (0, 5)) then cast('2017-06-05' as timestamp)\\n                        when (digit in (1, 6)) then cast('2017-06-08' as timestamp)\\n                        when (digit in (2, 7)) then cast('2017-06-20' as timestamp)\\n                        when (digit in (3, 8)) then cast('2017-06-21' as timestamp)\\n                        else cast('2017-07-15' as timestamp)\\n                      end as dis_dt\\n                    , cin_no, member_no\\n                    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n                    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n                    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n                    , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n                    , cur_pcp, cur_site_no, product_code, segment, yearmth\\n                    , rownumber\\n                    , digit\\n                from\\n                (\\n                    select\\n                        case_id\\n                        , cin_no, member_no\\n                        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n                        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n                        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n                        , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n                        , cur_pcp, cur_site_no, product_code, segment, yearmth\\n                        , rownumber\\n                        --, digit = right(rownumber, 1)\\n                        , case \\n                            when rownumber < 10 then rownumber\\n                            when rownumber between 10 and 99 then cast(substring(cast(rownumber as varchar(10)), 2, 1) as int) \\n                            else cast(substring(cast(rownumber as varchar(10)), 2, 1) as int) \\n                          end as digit\\n                    from nathalie.njb_unique_cases\\n                    limit 100\\n                ) as Subquery\\n                ;\\n                */\\n\\n/*\\nABSORB_TRANSFERS ---> no loop\\n--\\nON THE SUBJECT OF LOOPS: \\nImpala does not support any loop syntax (see https://stackoverflow.com/questions/49523380/write-a-while-loop-in-impala-sql)\\nTherefore as long as you need to fuse admits, you need to manually repeat the search-and-fuse script below. \\n*/\\n/*\\nThe following is alsways the 1st step and is only run one time\\n*/\\ncreate table njb_complete_cases_1\\nas\\nselect *\\nfrom\\n(    \\n    select \\n        case_id\\n        , adm_dt\\n        , dis_dt\\n        , cin_no\\n        , member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity\\n        , aprdrg\\n        , dis_status\\n        , provider\\n        , cur_pcp\\n        , cur_site_no\\n        , product_code\\n        , segment\\n        , yearmth\\n        , source_table\\n        , stay_interval\\n        , paid_amt_case\\n        , row_number() over(partition by member_no, dis_dt order by adm_dt asc) as rownumber --order newly engineered cases above cases that are transfers and whose admit date is later\\n    from\\n    ( -- DIS_DT_UPDATED // use stay_interval to compute new discharge date\\n        select \\n            case \\n                when stay_interval < 2 then ss_case_id\\n                else fs_case_id\\n            end as case_id\\n            , adm_dt\\n            ,   case\\n                    when stay_interval < 2 then ss_dis_dt\\n                    else fs_dis_dt\\n                end as dis_dt\\n            , cin_no\\n            , member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity\\n            , aprdrg\\n            , dis_status\\n            , provider\\n            , cur_pcp\\n            , cur_site_no\\n            , product_code\\n            , segment\\n            , yearmth\\n            , case\\n                when stay_interval < 2 then concat(fs_source_table, ss_source_table)\\n                else fs_source_table\\n            end as source_table\\n            , stay_interval\\n            , case\\n                when (stay_interval < 2 and fs_case_id != ss_case_id) then fs_paid_amt_case + ss_paid_amt_case\\n                else fs_paid_amt_case\\n            end as paid_amt_case\\n        from\\n        ( --'INTERVAL_ADDED' // add interval between 1st discharge date and 2nd admit date to create subquery called 'interval_added'\\n            select --select with priority QNXT > CLM > ENC and join with MEMMO data\\n                FS.case_id as fs_case_id, FS.adm_dt, FS.dis_dt as fs_dis_dt, FS.cin_no, FS.member_no\\n                , FS.case_dx1, FS.case_dx2, FS.case_dx3, FS.case_dx4, FS.case_dx5, FS.case_dx6, FS.case_dx7, FS.case_dx8, FS.case_dx9, FS.case_dx10\\n                , FS.case_dx11, FS.case_dx12, FS.case_dx13, FS.case_dx14, FS.case_dx15, FS.case_dx16, FS.case_dx17, FS.case_dx18, FS.case_dx19, FS.case_dx20 \\n                , FS.case_pr1, FS.case_pr2, FS.case_pr3, FS.case_pr4, FS.case_pr5, FS.case_pr6, FS.case_pr7, FS.case_pr8, FS.case_pr9, FS.case_pr10\\n                , FS.severity, FS.aprdrg, FS.dis_status, FS.provider\\n                , FS.cur_pcp, FS.cur_site_no, FS.product_code, FS.segment, FS.yearmth\\n                --, RIGHT('00' + CONVERT(VARCHAR, FS.source_table), 2) as fs_source_table\\n                , cast(FS.source_table as varchar(1)) as fs_source_table\\n                , SS.dis_dt as ss_dis_dt\\n                , concat(cast(FS.source_table as varchar(1)), ', ', cast(SS.source_table as varchar(1))) as ss_source_table\\n                , concat(FS.case_id, ', ', SS.case_id) as ss_case_id\\n                , case\\n                    when FS.member_no = SS.member_no \\n                        then abs(datediff(SS.adm_dt, FS.dis_dt)) -- absolute value selected bc w/ synthetic data, datediff under 1 month were neg, over 1 month pos --> did not find cause but this step appeared to be necessary for correct output\\n                        else null\\n                    end as stay_interval\\n                , FS.paid_amt_case as fs_paid_amt_case\\n                , SS.paid_amt_case as ss_paid_amt_case\\n            from\\n            NATHALIE.NJB_UNIQUE_CASES as FS --TK NEED TO SWITCH OUT OF SYNTHETIC DATA FOR ACTUAL QUERY\\n            --NATHALIE.njb_synthetic_UNIQUE_CASES as FS\\n            --order by UNIQUE_CASES.rownumber\\n            inner join\\n            NATHALIE.NJB_UNIQUE_CASES as SS --TK NEED TO SWITCH OUT OF SYNTHETIC DATA FOR ACTUAL QUERY\\n            --NATHALIE.njb_synthetic_UNIQUE_CASES as SS\\n            --order by UNIQUE_CASES.rownumber\\n            ON SS.rownumber = FS.rownumber + 1\\n        ) AS INTERVAL_ADDED\\n    ) AS DIS_DT_UPDATED\\n) AS ROWNUMER_ADDED\\nwhere rownumber = 1\\n;\", \"\\n/* add rownumber to the final product -- may not be necessary after you've written the loop \\n*/\\ncreate table NATHALIE.njb_complete_cases_2 as\\nselect \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , paid_amt_case\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom NATHALIE.njb_complete_cases_1\\n;\", \"\\n\\n/* count rows to see whether subsequent counts become lower */\\nselect count(*) from  njb_complete_cases_2;\", \"\\n--ANS:1,272,272\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/*\\nMANUALLY CONTROLLED LOOP\\nStart with table name: njb_complete_cases_2\\nHas columns: \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , paid_amt_case\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\n\\nTransformation: join with offset = 1, look for transfers, incorporate transfer dates and costs to 1 admission, delete transfer and renumber rows. \\n\\nEnd with table name njb_complete_case; has same columns as above\\n*/\\n\\n--create table nathalie.njb_complete_cases_3 \\ncreate table nathalie.njb_complete_cases_5\\nas\\nselect *\\nfrom\\n(    \\n    select \\n        case_id\\n        , adm_dt\\n        , dis_dt\\n        , cin_no\\n        , member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity\\n        , aprdrg\\n        , dis_status\\n        , provider\\n        , cur_pcp\\n        , cur_site_no\\n        , product_code\\n        , segment\\n        , yearmth\\n        , source_table\\n        , stay_interval\\n        , paid_amt_case\\n        , row_number() over(partition by member_no, dis_dt order by adm_dt asc) as rownumber --order newly engineered cases above cases that are transfers and whose admit date is later\\n    from\\n    ( -- DIS_DT_UPDATED // use stay_interval to compute new discharge date\\n        select \\n            case \\n                when stay_interval < 2 then ss_case_id\\n                else fs_case_id\\n            end as case_id\\n            , adm_dt\\n            ,   case\\n                    when stay_interval < 2 then ss_dis_dt\\n                    else fs_dis_dt\\n                end as dis_dt\\n            , cin_no\\n            , member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity\\n            , aprdrg\\n            , dis_status\\n            , provider\\n            , cur_pcp\\n            , cur_site_no\\n            , product_code\\n            , segment\\n            , yearmth\\n            , case\\n                when stay_interval < 2 then concat(fs_source_table, ss_source_table)\\n                else fs_source_table\\n            end as source_table\\n            , stay_interval\\n            , case\\n                when (stay_interval < 2 and fs_case_id != ss_case_id) then fs_paid_amt_case + ss_paid_amt_case \\n                else fs_paid_amt_case\\n            end as paid_amt_case\\n        from\\n        ( --'INTERVAL_ADDED' // add interval between 1st discharge date and 2nd admit date to create subquery called 'interval_added'\\n            select --select with priority QNXT > CLM > ENC and join with MEMMO data\\n                FS.case_id as fs_case_id, FS.adm_dt, FS.dis_dt as fs_dis_dt, FS.cin_no, FS.member_no\\n                , FS.case_dx1, FS.case_dx2, FS.case_dx3, FS.case_dx4, FS.case_dx5, FS.case_dx6, FS.case_dx7, FS.case_dx8, FS.case_dx9, FS.case_dx10\\n                , FS.case_dx11, FS.case_dx12, FS.case_dx13, FS.case_dx14, FS.case_dx15, FS.case_dx16, FS.case_dx17, FS.case_dx18, FS.case_dx19, FS.case_dx20 \\n                , FS.case_pr1, FS.case_pr2, FS.case_pr3, FS.case_pr4, FS.case_pr5, FS.case_pr6, FS.case_pr7, FS.case_pr8, FS.case_pr9, FS.case_pr10\\n                , FS.severity, FS.aprdrg, FS.dis_status, FS.provider\\n                , FS.cur_pcp, FS.cur_site_no, FS.product_code, FS.segment, FS.yearmth\\n                , cast(FS.source_table as varchar(1)) as fs_source_table\\n                , SS.dis_dt as ss_dis_dt\\n                , concat(cast(FS.source_table as varchar(1)), ', ', cast(SS.source_table as varchar(1))) as ss_source_table\\n                , concat(FS.case_id, ', ', SS.case_id) as ss_case_id\\n                , case\\n                    when FS.member_no = SS.member_no \\n                        then abs(datediff(SS.adm_dt, FS.dis_dt))\\n                        else null\\n                    end as stay_interval\\n                , FS.paid_amt_case as fs_paid_amt_case\\n                , SS.paid_amt_case as ss_paid_amt_case\\n            from\\n            --NATHALIE.NJB_COMPLETE_CASES_2 as FS \\n            NATHALIE.NJB_COMPLETE_CASES_4 as FS \\n            inner join\\n            --NATHALIE.NJB_COMPLETE_CASES_2 as SS\\n            NATHALIE.NJB_COMPLETE_CASES_4 as SS\\n            ON SS.rownumber = FS.rownumber + 1\\n        ) AS INTERVAL_ADDED\\n    ) AS DIS_DT_UPDATED\\n) AS ROWNUMER_ADDED\\nwhere rownumber = 1\\n;\", \"\\n/* add rownumber to the final product -- may not be necessary after you've written the loop \\n*/\\n--create table NATHALIE.njb_complete_cases_4 as\\ncreate table NATHALIE.njb_complete_cases_6 as\\nselect \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , paid_amt_case\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom NATHALIE.njb_complete_cases_5\\n--from NATHALIE.njb_complete_cases_7\\n;\", \"\\n\\n/* count rows to see whether subsequent counts become lower */\\n--select count(*) from  njb_complete_cases_4;\\nselect count(*) from  njb_complete_cases_6;\", \"\\n--ANS:1,272,272; 1,270,709; 1,270,693; 1270692; [se e 'last row' issue\\n--~to v6\\n\\n/*\\nSave the last iteration\\n*/\\ncreate table nathalie.njb_transfers_absorbed\\nas\\nselect *\\nfrom njb_complete_cases_6\\n;\", \"\\n\\n/*\\nNEXT STEP... \\nTake product of last step which gives you truly unique hospitatizations and label readmits + compute subpop stats...\\n*/\\n\\n/*\\nLABELED OUTCOME\\n--Compute labeled outcome: readmit in 30 d, or no readmit (2), or death in 30 days\\n--look for contiguous admits by juxtaposing a row with the row that follows it and taking a datedif between discharge and admit. Flag as contiguous stay (1) all with datedif < 2. \\n--need to repeat until longest continuous stay is isolated.\\n--TK !!! pad the 1st and last rows of 2 versions of NATHALIE.NJB_[input name]. This will help with the next step where the tables are joined by an offset row number.\\n*/\\ndrop view nathalie.njb_cases_with_labelled_outcomes;\", \"\\n\\ncreate table NATHALIE.njb_cases_with_labelled_outcomes as\\nSELECT \\n    case_id\\n    , a_dis_dt -- spot check\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , a_member_no -- spot check\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , rownumber\\n    , days_since_prior_discharge\\n    , prior_stay_case_id\\n    , case\\n        when days_since_prior_discharge <= 30 then 1 \\n        else 0 \\n      end as 30d_readmit\\n    , paid_amt_case\\nFROM\\n(\\n\\tSELECT \\n    \\t  B.case_id\\n        , A.dis_dt as a_dis_dt -- spot check\\n        , B.adm_dt\\n        , B.dis_dt\\n        , B.cin_no\\n        , B.member_no\\n        , A.member_no as a_member_no -- spot check\\n        , B.case_dx1, B.case_dx2, B.case_dx3, B.case_dx4, B.case_dx5, B.case_dx6, B.case_dx7, B.case_dx8, B.case_dx9, B.case_dx10\\n        , B.case_dx11, B.case_dx12, B.case_dx13, B.case_dx14, B.case_dx15, B.case_dx16, B.case_dx17, B.case_dx18, B.case_dx19, B.case_dx20 \\n        , B.case_pr1, B.case_pr2, B.case_pr3, B.case_pr4, B.case_pr5, B.case_pr6, B.case_pr7, B.case_pr8, B.case_pr9, B.case_pr10\\n        , B.severity\\n        , B.aprdrg\\n        , B.dis_status\\n        , B.provider\\n        , B.cur_pcp\\n        , B.cur_site_no\\n        , B.product_code\\n        , B.segment\\n        , B.yearmth\\n        , B.source_table\\n        , B.stay_interval\\n        , B.paid_amt_case\\n        , B.rownumber\\n    \\t, CASE\\n        \\t\\tWHEN A.member_no = B.member_no THEN ABS(DATEDIFF(A.dis_dt, B.adm_dt))\\n        \\t\\tELSE NULL\\n    \\t    END AS days_since_prior_discharge\\n    \\t, case\\n        \\t    when A.member_no = B.member_no then A.case_id\\n        \\t    else null\\n        \\tend as prior_stay_case_id\\n    FROM NATHALIE.njb_transfers_absorbed AS B LEFT JOIN NATHALIE.njb_transfers_absorbed AS A ON B.rownumber = A.rownumber + 1\\n) AS S\\n;\", \"\\n\\n\\n/*\\nBRING IN THE DEMOGRAPHICS\\n*/\\n\\n/*\\n    adm_dt\\n    , dis_dt\\n    , A.cin_no\\n    , A.member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , days_since_prior_discharge\\n    , case_id\\n    , prior_stay_case_id\\n    , 30d_readmit\\n    , paid_amt_case\\n    , dob\\n    , abs(datediff(dob, adm_dt)) as adm_age\\n    , gender\\n    , language_written_code\\n    , ethnicity_code\\n    , zip_code\\n    , zip4\\n    , deathdate\\n*/\\n\\ncreate table nathalie.demographics_added\\nas\\nselect \\n    adm_dt\\n    , dis_dt\\n    , A.cin_no\\n    , A.member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , A.product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , days_since_prior_discharge\\n    , case_id\\n    , prior_stay_case_id\\n    , 30d_readmit\\n    , paid_amt_case\\n    , dob\\n    , abs(datediff(dob, adm_dt)) as adm_age\\n    , gender\\n    , language_written_code\\n    , ethnicity_code\\n    , zip_code\\n    , zip4\\n    , deathdate\\nfrom nathalie.njb_cases_with_labelled_outcomes as A left join hoap.members as B on A.cin_no = B.cin_no\\n;\", \"\\n\\n\\n/*\\nLABEL THE LOBs and ENGINEER NEW NAMES (concatenate 10 + segment)\\n*/\\n\\n/*\\nTABULATE BY POPULATION\\nTK do you have the segmentation info you need?\\n-- LOB (eg CMC) Y\\n-- segment (eg SPD) Y\\n-- ??? Dx (HF, COPD, etc.) Y [but: across many fields; I may need to select a small number of the most common ones, and see rates and costs there)\\n-- ??? Age group (use C, TAY, A, S) --> Need to create a field for this\\n-- NEED TO COMPUTE Y: readmission rate is calculable in Excel (or in group by's); \\nAlso need count of admits, readmits, readmit cost exists in each segment [note here that what I cannot capture is opportunity for intervention vs. readmit will happen any way bc of illness type; see maybe success in applying TOC --> do such analyses exist contrasting dif. Dx?)\\n*/\\n\\nselect \\n    product_code\\n    , segment\\n    , source_table\\n    , 30d_readmit\\n    , count(*)\\n    , sum(paid_amt_case)\\nfrom nathalie.demographics_added\\n--where adm_age > 17\\n--and adm_age < 65\\ngroup by product_code, segment, source_table, 30d_readmit\\norder by product_code, segment, source_table, 30d_readmit\\n;\"], \"lastAceSelectionRowOffset\": 627, \"executingBlockingOperation\": null, \"errorsKlass\": \"results impala alert alert-error\", \"statement\": \"/***\\n20180414\\n***/\\n\\n/*\\nUNIQUE_CASES\\n--Select all unique cases across QNXT, CLM and ENC, deduplicating with priority QNXT>CLM>ENC. \\n--Join with MEMMO information about LOB\\n--Contains on separate rows nitial admits and transfers (continuous stays). These will be unified into single stays on a subsequent step.\\n--Top-level select has : row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\n*/\\n/*\\ncreate table NATHALIE.NJB_UNIQUE_CASES \\nas\\nselect \\n    case_id, adm_dt, dis_dt, UNIQUE_CASES.cin_no, member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n    , cur_pcp, cur_site_no, product_code, segment, yearmth\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom\\n(--select unique tupple (member_no, admi_dt, dis_dt) tupple with priority QNXT>CLM>ENC\\n    select *\\n    from\\n    ( --add number rows inside partitions where each partition is a unique (member_no, admi_dt, dis_dt) tupple\\n        select case_id, adm_dt, dis_dt, cin_no, member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n        , row_number() over(partition by member_no, adm_dt, dis_dt order by source_table asc, case_id desc) as rownumber\\n        from\\n        ( -- union of cases across 3 data tables: qnxt, clm, enc\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, paid_amt_case\\n            , 1 as source_table\\n            --from `hoap`.`tmp_QNXT_CASE_INPSNF`\\n            from `hoap`.`QNXT_CASE_INPSNF`\\n            union\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, paid_amt_case\\n            , 2 as source_table\\n            --from `hoap`.`tmp_clm_case_inpsnf`\\n            from `hoap`.`clm_case_inpsnf`\\n            union\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, null as paid_amt_case\\n            , 3 as source_table\\n            --from `hoap`.`tmp_ENC_CASE_INPSNF`\\n            from `hoap`.`ENC_CASE_INPSNF`\\n        ) AS ALL_CASES\\n        order by member_no, adm_dt, dis_dt\\n    ) ALL_CASES_PARTITIONED\\n    where rownumber =  1\\n) as UNIQUE_CASES  \\nleft join\\n( -- member information from MEMMO table\\n    select cin_no, cur_pcp, cur_site_no, product_code, segment, yearmth\\n    from \\n    ( -- rank identical cin_no by recncy in order to unique rows by cin_no\\n        select cin_no, pcp as cur_pcp, site_no as cur_site_no, product_code, segment, yearmth\\n        , row_number() over(partition by cin_no order by yearmth desc) as rownumber\\n        --from `HOAP`.`tmp_memmo`\\n        from `HOAP`.`memmo`\\n    ) as M\\n    where rownumber = 1\\n) as MEMMO\\non UNIQUE_CASES.cin_no = MEMMO.cin_no\\n;\\n*/\\n\\n                /*\\n                SYNTHETIC DATA \\n                */\\n                /*\\n                create view nathalie.njb_synthetic_unique_cases as\\n                select\\n                    case_id\\n                    , case \\n                        when (digit in (0, 5)) then cast('2017-06-01' as timestamp)\\n                        when (digit in (1, 6)) then cast('2017-06-06' as timestamp)\\n                        when (digit in (2, 7)) then cast('2017-06-11' as timestamp)\\n                        when (digit in (3, 8)) then cast('2017-06-21' as timestamp)\\n                        else cast('2017-06-26' as timestamp)\\n                      end as adm_dt\\n                    , case \\n                        when (digit in (0, 5)) then cast('2017-06-05' as timestamp)\\n                        when (digit in (1, 6)) then cast('2017-06-08' as timestamp)\\n                        when (digit in (2, 7)) then cast('2017-06-20' as timestamp)\\n                        when (digit in (3, 8)) then cast('2017-06-21' as timestamp)\\n                        else cast('2017-07-15' as timestamp)\\n                      end as dis_dt\\n                    , cin_no, member_no\\n                    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n                    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n                    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n                    , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n                    , cur_pcp, cur_site_no, product_code, segment, yearmth\\n                    , rownumber\\n                    , digit\\n                from\\n                (\\n                    select\\n                        case_id\\n                        , cin_no, member_no\\n                        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n                        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n                        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n                        , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n                        , cur_pcp, cur_site_no, product_code, segment, yearmth\\n                        , rownumber\\n                        --, digit = right(rownumber, 1)\\n                        , case \\n                            when rownumber < 10 then rownumber\\n                            when rownumber between 10 and 99 then cast(substring(cast(rownumber as varchar(10)), 2, 1) as int) \\n                            else cast(substring(cast(rownumber as varchar(10)), 2, 1) as int) \\n                          end as digit\\n                    from nathalie.njb_unique_cases\\n                    limit 100\\n                ) as Subquery\\n                ;\\n                */\\n\\n/*\\nABSORB_TRANSFERS ---> no loop\\n--\\nON THE SUBJECT OF LOOPS: \\nImpala does not support any loop syntax (see https://stackoverflow.com/questions/49523380/write-a-while-loop-in-impala-sql)\\nTherefore as long as you need to fuse admits, you need to manually repeat the search-and-fuse script below. \\n*/\\n/*\\nThe following is alsways the 1st step and is only run one time\\n*/\\ncreate table njb_complete_cases_1\\nas\\nselect *\\nfrom\\n(    \\n    select \\n        case_id\\n        , adm_dt\\n        , dis_dt\\n        , cin_no\\n        , member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity\\n        , aprdrg\\n        , dis_status\\n        , provider\\n        , cur_pcp\\n        , cur_site_no\\n        , product_code\\n        , segment\\n        , yearmth\\n        , source_table\\n        , stay_interval\\n        , paid_amt_case\\n        , row_number() over(partition by member_no, dis_dt order by adm_dt asc) as rownumber --order newly engineered cases above cases that are transfers and whose admit date is later\\n    from\\n    ( -- DIS_DT_UPDATED // use stay_interval to compute new discharge date\\n        select \\n            case \\n                when stay_interval < 2 then ss_case_id\\n                else fs_case_id\\n            end as case_id\\n            , adm_dt\\n            ,   case\\n                    when stay_interval < 2 then ss_dis_dt\\n                    else fs_dis_dt\\n                end as dis_dt\\n            , cin_no\\n            , member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity\\n            , aprdrg\\n            , dis_status\\n            , provider\\n            , cur_pcp\\n            , cur_site_no\\n            , product_code\\n            , segment\\n            , yearmth\\n            , case\\n                when stay_interval < 2 then concat(fs_source_table, ss_source_table)\\n                else fs_source_table\\n            end as source_table\\n            , stay_interval\\n            , case\\n                when (stay_interval < 2 and fs_case_id != ss_case_id) then fs_paid_amt_case + ss_paid_amt_case\\n                else fs_paid_amt_case\\n            end as paid_amt_case\\n        from\\n        ( --'INTERVAL_ADDED' // add interval between 1st discharge date and 2nd admit date to create subquery called 'interval_added'\\n            select --select with priority QNXT > CLM > ENC and join with MEMMO data\\n                FS.case_id as fs_case_id, FS.adm_dt, FS.dis_dt as fs_dis_dt, FS.cin_no, FS.member_no\\n                , FS.case_dx1, FS.case_dx2, FS.case_dx3, FS.case_dx4, FS.case_dx5, FS.case_dx6, FS.case_dx7, FS.case_dx8, FS.case_dx9, FS.case_dx10\\n                , FS.case_dx11, FS.case_dx12, FS.case_dx13, FS.case_dx14, FS.case_dx15, FS.case_dx16, FS.case_dx17, FS.case_dx18, FS.case_dx19, FS.case_dx20 \\n                , FS.case_pr1, FS.case_pr2, FS.case_pr3, FS.case_pr4, FS.case_pr5, FS.case_pr6, FS.case_pr7, FS.case_pr8, FS.case_pr9, FS.case_pr10\\n                , FS.severity, FS.aprdrg, FS.dis_status, FS.provider\\n                , FS.cur_pcp, FS.cur_site_no, FS.product_code, FS.segment, FS.yearmth\\n                --, RIGHT('00' + CONVERT(VARCHAR, FS.source_table), 2) as fs_source_table\\n                , cast(FS.source_table as varchar(1)) as fs_source_table\\n                , SS.dis_dt as ss_dis_dt\\n                , concat(cast(FS.source_table as varchar(1)), ', ', cast(SS.source_table as varchar(1))) as ss_source_table\\n                , concat(FS.case_id, ', ', SS.case_id) as ss_case_id\\n                , case\\n                    when FS.member_no = SS.member_no \\n                        then abs(datediff(SS.adm_dt, FS.dis_dt)) -- absolute value selected bc w/ synthetic data, datediff under 1 month were neg, over 1 month pos --> did not find cause but this step appeared to be necessary for correct output\\n                        else null\\n                    end as stay_interval\\n                , FS.paid_amt_case as fs_paid_amt_case\\n                , SS.paid_amt_case as ss_paid_amt_case\\n            from\\n            NATHALIE.NJB_UNIQUE_CASES as FS --TK NEED TO SWITCH OUT OF SYNTHETIC DATA FOR ACTUAL QUERY\\n            --NATHALIE.njb_synthetic_UNIQUE_CASES as FS\\n            --order by UNIQUE_CASES.rownumber\\n            inner join\\n            NATHALIE.NJB_UNIQUE_CASES as SS --TK NEED TO SWITCH OUT OF SYNTHETIC DATA FOR ACTUAL QUERY\\n            --NATHALIE.njb_synthetic_UNIQUE_CASES as SS\\n            --order by UNIQUE_CASES.rownumber\\n            ON SS.rownumber = FS.rownumber + 1\\n        ) AS INTERVAL_ADDED\\n    ) AS DIS_DT_UPDATED\\n) AS ROWNUMER_ADDED\\nwhere rownumber = 1\\n;\", \"type\": \"impala\", \"chartSorting\": \"none\", \"previousChartOptions\": {\"chartTimelineType\": \"bar\", \"chartSorting\": \"none\", \"chartLimit\": null, \"chartMapHeat\": null, \"chartX\": \"product_code\", \"chartMapType\": \"marker\", \"chartYMulti\": [\"count(*)\"], \"chartScatterSize\": null, \"chartScope\": \"world\", \"chartMapLabel\": null, \"chartScatterGroup\": null, \"chartYSingle\": null, \"chartXPivot\": null}, \"aceWarningsHolder\": [], \"resultsKlass\": \"results impala\", \"delayedDDLNotification\": 0.19689942156066298, \"chartTimelineType\": \"bar\", \"compatibilityTargetPlatforms\": [{\"name\": \"Impala\", \"value\": \"impala\"}, {\"name\": \"Hive\", \"value\": \"hive\"}], \"topRisk\": null, \"hasCurlyBracketParameters\": true, \"chartScatterGroup\": null, \"settingsVisible\": false, \"queriesFilterVisible\": false, \"aceWarnings\": [], \"compatibilityCheckRunning\": false, \"isLoading\": false, \"loadingQueries\": false, \"hasDataForChart\": true, \"id\": \"a6d5440f-625f-4591-5e35-21322280e31b\", \"aceSize\": 100, \"chartData\": [], \"queriesHasErrors\": false, \"chartMapLabel\": null, \"status\": \"available\", \"isSqlDialect\": true, \"chartMapType\": \"marker\", \"queriesFilter\": \"\", \"queriesCurrentPage\": 1, \"isBatchable\": true, \"chartYMulti\": [\"count(*)\"], \"dbSelectionVisible\": false, \"database\": \"nathalie\", \"hasSuggestion\": null, \"chartXPivot\": null, \"checkStatusTimeout\": null}], \"isHistory\": false, \"type\": \"query-impala\", \"historyFilter\": \"\", \"description\": \"readmission rate and cost subpopulation contrast\", \"sessions\": [{\"properties\": [{\"multiple\": true, \"defaultValue\": [], \"value\": [], \"nice_name\": \"Settings\", \"key\": \"settings\", \"help_text\": \"Impala configuration properties.\", \"type\": \"settings\", \"options\": [\"debug_action\", \"explain_level\", \"mem_limit\", \"optimize_partition_key_scans\", \"query_timeout_s\", \"request_pool\"]}], \"type\": \"impala\", \"id\": 4921, \"http_addr\": \"http://dsdata1.lacare.org:25000\"}], \"updateHistoryFailed\": false, \"presentationSnippets\": {}, \"isBatchable\": true, \"selectedSnippet\": \"impala\", \"coordinatorUuid\": null, \"name\": \"read_ratecost_by_subpopulation\", \"isManaged\": false, \"loadingScheduler\": false, \"viewSchedulerId\": \"\", \"isSaved\": true, \"historyCurrentPage\": 1, \"creatingSessionLocks\": [], \"directoryUuid\": \"\", \"parentSavedQueryUuid\": \"86dc0fd4-4e43-2a54-36cf-70c4b1b42332\", \"dependentsCoordinator\": []}", 
    "is_trashed": false, 
    "name": "read_ratecost_by_subpopulation"
  }
}
]
