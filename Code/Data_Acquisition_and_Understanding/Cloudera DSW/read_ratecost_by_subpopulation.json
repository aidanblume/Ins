[
{
  "pk": 22886, 
  "model": "desktop.document2", 
  "fields": {
    "search": "select \n    product_code --this ...\n    , segment --...and this can be combined by case in order to produce LOBs. See code excerpts above (RE: \"product_codes\"; offset from Left)for guidance. \n    , is_followed_by_a_30d_readmit\n    , count(*)\nfrom nathalie.NJB_ANALYTIC_SET\n--where adm_age > 17 --TK filter is needed, but data field is poorly populated and reduces counts too much. Need to find alternative DOB source. \n--and adm_age < 65\ngroup by product_code, segment, is_followed_by_a_30d_readmit\norder by product_code, segment, is_followed_by_a_30d_readmit", 
    "uuid": "86dc0fd4-4e43-2a54-36cf-70c4b1b42332", 
    "extra": "", 
    "type": "query-impala", 
    "description": "readmission rate and cost subpopulation contrast", 
    "is_history": false, 
    "parent_directory": [
      "66b0fa47-f592-4e6a-b569-99ad2a42956e", 
      1, 
      false
    ], 
    "is_managed": false, 
    "last_modified": "2018-04-17T12:04:42.192", 
    "version": 1, 
    "owner": [
      "nathalieb"
    ], 
    "dependencies": [], 
    "data": "{\"loadingHistory\": false, \"schedulerViewModel\": null, \"retryModalCancel\": null, \"schedulerViewModelIsLoaded\": false, \"historyTotalPages\": 10, \"unloaded\": false, \"id\": 22886, \"retryModalConfirm\": null, \"uuid\": \"8f7d0ed3-f16d-4f01-bb4a-7a6a0033184b\", \"onSuccessUrl\": null, \"is_history\": false, \"historyFilterVisible\": false, \"snippets\": [{\"wasBatchExecuted\": false, \"chartLimits\": [5, 10, 25, 50, 100], \"associatedDocumentLoading\": true, \"isReady\": true, \"statement_raw\": \"/***\\n20180414\\n***/\\n\\n\\n/*\\nUNIQUE_CASES\\n*/\\n\\n/*\\n--Select all unique cases across QNXT, CLM and ENC, deduplicating with priority QNXT>CLM>ENC. \\n--Join with MEMMO information about LOB\\n--Contains on separate rows nitial admits and transfers (continuous stays). These will be unified into single stays on a subsequent step.\\n--Top-level select has : row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\n*/\\n\\ncreate table NATHALIE.NJB_UNIQUE_CASES \\nas\\nselect \\n    case_id, adm_dt, dis_dt, UNIQUE_CASES.cin_no, member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n    , cur_pcp, cur_site_no, product_code, segment, yearmth\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom\\n(--select unique tupple (member_no, admi_dt, dis_dt) tupple with priority QNXT>CLM>ENC\\n    select *\\n    from\\n    ( --add number rows inside partitions where each partition is a unique (member_no, admi_dt, dis_dt) tupple\\n        select case_id, adm_dt, dis_dt, cin_no, member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n        , row_number() over(partition by member_no, adm_dt, dis_dt order by source_table asc, case_id desc) as rownumber\\n        from\\n        ( -- union of cases across 3 data tables: qnxt, clm, enc\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, paid_amt_case\\n            , 1 as source_table\\n            --from `hoap`.`tmp_QNXT_CASE_INPSNF`\\n            from `hoap`.`QNXT_CASE_INPSNF`\\n            union\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, paid_amt_case\\n            , 2 as source_table\\n            --from `hoap`.`tmp_clm_case_inpsnf`\\n            from `hoap`.`clm_case_inpsnf`\\n            union\\n            select case_id, adm_dt, dis_dt, cin_no, member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity, aprdrg, dis_status, provider, null as paid_amt_case\\n            , 3 as source_table\\n            --from `hoap`.`tmp_ENC_CASE_INPSNF`\\n            from `hoap`.`ENC_CASE_INPSNF`\\n        ) AS ALL_CASES\\n        order by member_no, adm_dt, dis_dt\\n    ) ALL_CASES_PARTITIONED\\n    where rownumber =  1\\n) as UNIQUE_CASES  \\nleft join\\n( -- member information from MEMMO table\\n    select cin_no, cur_pcp, cur_site_no, product_code, segment, yearmth\\n    from \\n    ( -- rank identical cin_no by recncy in order to unique rows by cin_no\\n        select cin_no, pcp as cur_pcp, site_no as cur_site_no, product_code, segment, yearmth\\n        , row_number() over(partition by cin_no order by yearmth desc) as rownumber\\n        --from `HOAP`.`tmp_memmo`\\n        from `HOAP`.`memmo`\\n    ) as M\\n    where rownumber = 1\\n) as MEMMO\\non UNIQUE_CASES.cin_no = MEMMO.cin_no\\n;\\n\\n                /*\\n                SYNTHETIC DATA \\n                */\\n                /*\\n                create view nathalie.njb_synthetic_unique_cases as\\n                select\\n                    case_id\\n                    , case \\n                        when (digit in (0, 5)) then cast('2017-06-01' as timestamp)\\n                        when (digit in (1, 6)) then cast('2017-06-06' as timestamp)\\n                        when (digit in (2, 7)) then cast('2017-06-11' as timestamp)\\n                        when (digit in (3, 8)) then cast('2017-06-21' as timestamp)\\n                        else cast('2017-06-26' as timestamp)\\n                      end as adm_dt\\n                    , case \\n                        when (digit in (0, 5)) then cast('2017-06-05' as timestamp)\\n                        when (digit in (1, 6)) then cast('2017-06-08' as timestamp)\\n                        when (digit in (2, 7)) then cast('2017-06-20' as timestamp)\\n                        when (digit in (3, 8)) then cast('2017-06-21' as timestamp)\\n                        else cast('2017-07-15' as timestamp)\\n                      end as dis_dt\\n                    , cin_no, member_no\\n                    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n                    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n                    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n                    , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n                    , cur_pcp, cur_site_no, product_code, segment, yearmth\\n                    , rownumber\\n                    , digit\\n                from\\n                (\\n                    select\\n                        case_id\\n                        , cin_no, member_no\\n                        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n                        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n                        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n                        , severity, aprdrg, dis_status, provider, paid_amt_case, source_table\\n                        , cur_pcp, cur_site_no, product_code, segment, yearmth\\n                        , rownumber\\n                        --, digit = right(rownumber, 1)\\n                        , case \\n                            when rownumber < 10 then rownumber\\n                            when rownumber between 10 and 99 then cast(substring(cast(rownumber as varchar(10)), 2, 1) as int) \\n                            else cast(substring(cast(rownumber as varchar(10)), 2, 1) as int) \\n                          end as digit\\n                    from nathalie.njb_unique_cases\\n                    limit 100\\n                ) as Subquery\\n                ;\\n                */\\n\\n\\n/*\\nABSORB_TRANSFERS ---> no loop\\n*/\\n\\n/*\\nON THE SUBJECT OF LOOPS: \\nImpala does not support any loop syntax (see https://stackoverflow.com/questions/49523380/write-a-while-loop-in-impala-sql)\\nTherefore as long as you need to fuse admits, you need to manually repeat the search-and-fuse script below. \\n*/\\n\\n/*\\nThe following is alsways the 1st step and is only run one time\\n*/\\n\\ncreate table njb_complete_cases_1\\nas\\nselect *\\nfrom\\n(    \\n    select \\n        case_id\\n        , adm_dt\\n        , dis_dt\\n        , cin_no\\n        , member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity\\n        , aprdrg\\n        , dis_status\\n        , provider\\n        , cur_pcp\\n        , cur_site_no\\n        , product_code\\n        , segment\\n        , yearmth\\n        , source_table\\n        , stay_interval\\n        , paid_amt_case\\n        , row_number() over(partition by member_no, dis_dt order by adm_dt asc) as rownumber --order newly engineered cases above cases that are transfers and whose admit date is later\\n    from\\n    ( -- DIS_DT_UPDATED // use stay_interval to compute new discharge date\\n        select \\n            case \\n                when stay_interval < 2 then ss_case_id\\n                else fs_case_id\\n            end as case_id\\n            , adm_dt\\n            ,   case\\n                    when stay_interval < 2 then ss_dis_dt\\n                    else fs_dis_dt\\n                end as dis_dt\\n            , cin_no\\n            , member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity\\n            , aprdrg\\n            , dis_status\\n            , provider\\n            , cur_pcp\\n            , cur_site_no\\n            , product_code\\n            , segment\\n            , yearmth\\n            , case\\n                when stay_interval < 2 then concat(fs_source_table, ', ', ss_source_table)\\n                else fs_source_table\\n            end as source_table\\n            , stay_interval\\n            , case\\n                when (stay_interval < 2 and fs_case_id != ss_case_id) then fs_paid_amt_case + ss_paid_amt_case\\n                else fs_paid_amt_case\\n            end as paid_amt_case\\n        from\\n        ( --'INTERVAL_ADDED' // add interval between 1st discharge date and 2nd admit date to create subquery called 'interval_added'\\n            select --select with priority QNXT > CLM > ENC and join with MEMMO data\\n                FS.case_id as fs_case_id, FS.adm_dt, FS.dis_dt as fs_dis_dt, FS.cin_no, FS.member_no\\n                , FS.case_dx1, FS.case_dx2, FS.case_dx3, FS.case_dx4, FS.case_dx5, FS.case_dx6, FS.case_dx7, FS.case_dx8, FS.case_dx9, FS.case_dx10\\n                , FS.case_dx11, FS.case_dx12, FS.case_dx13, FS.case_dx14, FS.case_dx15, FS.case_dx16, FS.case_dx17, FS.case_dx18, FS.case_dx19, FS.case_dx20 \\n                , FS.case_pr1, FS.case_pr2, FS.case_pr3, FS.case_pr4, FS.case_pr5, FS.case_pr6, FS.case_pr7, FS.case_pr8, FS.case_pr9, FS.case_pr10\\n                , FS.severity, FS.aprdrg, FS.dis_status, FS.provider\\n                , FS.cur_pcp, FS.cur_site_no, FS.product_code, FS.segment, FS.yearmth\\n                --, RIGHT('00' + CONVERT(VARCHAR, FS.source_table), 2) as fs_source_table\\n                , cast(FS.source_table as varchar(1)) as fs_source_table\\n                , SS.dis_dt as ss_dis_dt\\n                , concat(cast(FS.source_table as varchar(1)), ', ', cast(SS.source_table as varchar(1))) as ss_source_table\\n                , concat(FS.case_id, ', ', SS.case_id) as ss_case_id\\n                , case\\n                    when FS.member_no = SS.member_no \\n                        then abs(datediff(SS.adm_dt, FS.dis_dt)) -- absolute value selected bc w/ synthetic data, datediff under 1 month were neg, over 1 month pos --> did not find cause but this step appeared to be necessary for correct output\\n                        else null\\n                    end as stay_interval\\n                , FS.paid_amt_case as fs_paid_amt_case\\n                , SS.paid_amt_case as ss_paid_amt_case\\n            from\\n            NATHALIE.NJB_UNIQUE_CASES as FS --TK NEED TO SWITCH OUT OF SYNTHETIC DATA FOR ACTUAL QUERY\\n            --NATHALIE.njb_synthetic_UNIQUE_CASES as FS\\n            --order by UNIQUE_CASES.rownumber\\n            inner join\\n            NATHALIE.NJB_UNIQUE_CASES as SS --TK NEED TO SWITCH OUT OF SYNTHETIC DATA FOR ACTUAL QUERY\\n            --NATHALIE.njb_synthetic_UNIQUE_CASES as SS\\n            --order by UNIQUE_CASES.rownumber\\n            ON SS.rownumber = FS.rownumber + 1\\n        ) AS INTERVAL_ADDED\\n    ) AS DIS_DT_UPDATED\\n) AS ROWNUMER_ADDED\\nwhere rownumber = 1\\n;\\n\\n/* \\nadd rownumber to the final product -- may not be necessary after you've written the loop \\n*/\\n\\ncreate table NATHALIE.njb_complete_cases_2 as\\nselect \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , paid_amt_case\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom NATHALIE.njb_complete_cases_1\\n;\\n\\n\\n\\n\\n/*\\nMANUALLY CONTROLLED LOOP\\n*/\\n\\n/*\\nStart with table name: njb_complete_cases_2\\nHas columns: \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , paid_amt_case\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\n\\nTransformation: join with offset = 1, look for transfers, incorporate transfer dates and costs to 1 admission, delete transfer and renumber rows. \\n\\nEnd with table name njb_complete_case; has same columns as above\\n*/\\n\\n--create table nathalie.njb_complete_cases_3 \\ncreate table nathalie.njb_complete_cases_5\\nas\\nselect *\\nfrom\\n(    \\n    select \\n        case_id\\n        , adm_dt\\n        , dis_dt\\n        , cin_no\\n        , member_no\\n        , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n        , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n        , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n        , severity\\n        , aprdrg\\n        , dis_status\\n        , provider\\n        , cur_pcp\\n        , cur_site_no\\n        , product_code\\n        , segment\\n        , yearmth\\n        , source_table\\n        , stay_interval\\n        , paid_amt_case\\n        , row_number() over(partition by member_no, dis_dt order by adm_dt asc) as rownumber --order newly engineered cases above cases that are transfers and whose admit date is later\\n    from\\n    ( -- DIS_DT_UPDATED // use stay_interval to compute new discharge date\\n        select \\n            case \\n                when stay_interval < 2 then ss_case_id\\n                else fs_case_id\\n            end as case_id\\n            , adm_dt\\n            ,   case\\n                    when stay_interval < 2 then ss_dis_dt\\n                    else fs_dis_dt\\n                end as dis_dt\\n            , cin_no\\n            , member_no\\n            , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n            , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n            , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n            , severity\\n            , aprdrg\\n            , dis_status\\n            , provider\\n            , cur_pcp\\n            , cur_site_no\\n            , product_code\\n            , segment\\n            , yearmth\\n            , case\\n                when stay_interval < 2 then concat(fs_source_table, ', ', ss_source_table)\\n                else fs_source_table\\n            end as source_table\\n            , stay_interval\\n            , case\\n                when (stay_interval < 2 and fs_case_id != ss_case_id) then fs_paid_amt_case + ss_paid_amt_case \\n                else fs_paid_amt_case\\n            end as paid_amt_case\\n        from\\n        ( --'INTERVAL_ADDED' // add interval between 1st discharge date and 2nd admit date to create subquery called 'interval_added'\\n            select --select with priority QNXT > CLM > ENC and join with MEMMO data\\n                FS.case_id as fs_case_id, FS.adm_dt, FS.dis_dt as fs_dis_dt, FS.cin_no, FS.member_no\\n                , FS.case_dx1, FS.case_dx2, FS.case_dx3, FS.case_dx4, FS.case_dx5, FS.case_dx6, FS.case_dx7, FS.case_dx8, FS.case_dx9, FS.case_dx10\\n                , FS.case_dx11, FS.case_dx12, FS.case_dx13, FS.case_dx14, FS.case_dx15, FS.case_dx16, FS.case_dx17, FS.case_dx18, FS.case_dx19, FS.case_dx20 \\n                , FS.case_pr1, FS.case_pr2, FS.case_pr3, FS.case_pr4, FS.case_pr5, FS.case_pr6, FS.case_pr7, FS.case_pr8, FS.case_pr9, FS.case_pr10\\n                , FS.severity, FS.aprdrg, FS.dis_status, FS.provider\\n                , FS.cur_pcp, FS.cur_site_no, FS.product_code, FS.segment, FS.yearmth\\n                , cast(FS.source_table as varchar(1)) as fs_source_table\\n                , SS.dis_dt as ss_dis_dt\\n                , concat(cast(FS.source_table as varchar(1)), ', ', cast(SS.source_table as varchar(1))) as ss_source_table\\n                , concat(FS.case_id, ', ', SS.case_id) as ss_case_id\\n                , case\\n                    when FS.member_no = SS.member_no \\n                        then abs(datediff(SS.adm_dt, FS.dis_dt))\\n                        else null\\n                    end as stay_interval\\n                , FS.paid_amt_case as fs_paid_amt_case\\n                , SS.paid_amt_case as ss_paid_amt_case\\n            from\\n            --NATHALIE.NJB_COMPLETE_CASES_2 as FS \\n            NATHALIE.NJB_COMPLETE_CASES_4 as FS \\n            inner join\\n            --NATHALIE.NJB_COMPLETE_CASES_2 as SS\\n            NATHALIE.NJB_COMPLETE_CASES_4 as SS\\n            ON SS.rownumber = FS.rownumber + 1\\n        ) AS INTERVAL_ADDED\\n    ) AS DIS_DT_UPDATED\\n) AS ROWNUMER_ADDED\\nwhere rownumber = 1\\n;\\n\\n/* \\nadd rownumber to the final product \\n*/\\n\\n--create table NATHALIE.njb_complete_cases_4 as\\ncreate table NATHALIE.njb_complete_cases_6 as\\nselect \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , cin_no\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , paid_amt_case\\n    , row_number() over (order by member_no asc, adm_dt asc, dis_dt asc) as rownumber\\nfrom NATHALIE.njb_complete_cases_5\\n--from NATHALIE.njb_complete_cases_7\\n;\\n\\n/* \\ncount rows to see whether subsequent counts become lower \\n*/\\n\\n--select count(*) from  njb_complete_cases_4;\\nselect count(*) from  njb_complete_cases_6;\\n--ANS:1,272,272; 1,270,709; 1,270,693; 1270692; [see 'last row' issue.]\\n--~to v6\\n\\n/*\\nSave the last iteration\\n*/\\ncreate table nathalie.njb_transfers_absorbed\\nas\\nselect *\\nfrom njb_complete_cases_6\\n;\\n\\n\\n/*\\nINDEX vs READMITS: for each case, is it preceded by an index readmission within 30 days or not? Label 'I' if no, and 'R' if yes. \\n*/\\n\\n/*\\n--Compute labeled outcome: is index only or is readmit (I vs R)\\n--TK !!! pad the 1st and last rows of 2 versions of NATHALIE.NJB_[input name]. This will help with the next step where the tables are joined by an offset row number.\\n*/\\n\\n--Add a dummy row to a copy of nathalie.njb_transfers_absorbed called njb_A, whose rownumber is 0, dis_dt/adm_dt are 100 years in past, and other vals are null\\n--Use thus to solve problem of sheared row on next steps\\ncreate table NATHALIE.njb_A as\\nselect * from NATHALIE.njb_transfers_absorbed;\\n\\ninsert into NATHALIE.njb_A (adm_dt, dis_dt, rownumber)\\nvalues('1900-01-01', '1900-01-01', 0);\\n\\n--join table with offset 1 and save values for latest admit per row, plus data concerning earliest admit that indicates whether target is Index (only) vs. Readmit\\ncreate table NATHALIE.njb_labeled_as_readmits as\\nSELECT \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , a_dis_dt -- spot check\\n    , cin_no\\n    , a_cin_no -- spot check\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , rownumber\\n    , days_since_prior_discharge\\n    , prior_stay_case_id\\n    , case\\n        when days_since_prior_discharge <= 30 then 1 \\n        else 0 \\n      end as is_a_30d_readmit\\n    , paid_amt_case\\nFROM\\n(\\n\\tSELECT \\n    \\t  B.case_id\\n        , B.adm_dt\\n        , B.dis_dt\\n        , A.dis_dt as a_dis_dt -- spot check\\n        , B.cin_no\\n        , A.cin_no as a_cin_no -- spot check\\n        , B.member_no\\n        , B.case_dx1, B.case_dx2, B.case_dx3, B.case_dx4, B.case_dx5, B.case_dx6, B.case_dx7, B.case_dx8, B.case_dx9, B.case_dx10\\n        , B.case_dx11, B.case_dx12, B.case_dx13, B.case_dx14, B.case_dx15, B.case_dx16, B.case_dx17, B.case_dx18, B.case_dx19, B.case_dx20 \\n        , B.case_pr1, B.case_pr2, B.case_pr3, B.case_pr4, B.case_pr5, B.case_pr6, B.case_pr7, B.case_pr8, B.case_pr9, B.case_pr10\\n        , B.severity\\n        , B.aprdrg\\n        , B.dis_status\\n        , B.provider\\n        , B.cur_pcp\\n        , B.cur_site_no\\n        , B.product_code\\n        , B.segment\\n        , B.yearmth\\n        , B.source_table\\n        , B.stay_interval\\n        , B.paid_amt_case\\n        , B.rownumber\\n    \\t, CASE\\n        \\t\\tWHEN A.member_no = B.member_no THEN ABS(DATEDIFF(A.dis_dt, B.adm_dt))\\n        \\t\\tELSE NULL\\n    \\t    END AS days_since_prior_discharge\\n    \\t, case\\n        \\t    when A.member_no = B.member_no then A.case_id\\n        \\t    else null\\n        \\tend as prior_stay_case_id\\n    FROM NATHALIE.njb_A AS A LEFT JOIN NATHALIE.njb_transfers_absorbed AS B ON A.rownumber = B.rownumber - 1 -- A is earlier than B; 1st row for A is nulls/ancient dates\\n) AS S\\n;\\n\\n\\n\\n\\n\\n/*\\nLABELED OUTCOME: for each case, is it followed by a readmission within 30 days or not\\n*/\\n\\n/*\\n--Compute labeled outcome: readmit in 30 d, or no readmit (2), or death in 30 days\\n--TK !!! pad the 1st and last rows of 2 versions of NATHALIE.NJB_[input name]. This will help with the next step where the tables are joined by an offset row number.\\n*/\\n\\n--Add a dummy row to a copy of nathalie.njb_transfers_absorbed called njb_A, whose rownumber is 0, dis_dt/adm_dt are 100 years in past, and other vals are null\\n--Use thus to solve problem of sheared row on next steps\\n\\ndrop table nathalie.njb_a;\\n\\ncreate table NATHALIE.njb_A as\\nselect * from NATHALIE.njb_labeled_as_readmits;\\n\\ninsert into NATHALIE.njb_A (adm_dt, dis_dt, rownumber)\\nvalues('1900-01-01', '1900-01-01', 0);\\n\\n--drop table nathalie.njb_labeled_outcomes;\\n\\n--main computation\\ncreate table NATHALIE.njb_labeled_outcomes as\\nSELECT \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , a_dis_dt -- spot check\\n    , b_dis_dt -- spot check\\n    , cin_no\\n    , a_cin_no -- spot check\\n    , b_cin_no -- spot check\\n    , member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , rownumber\\n    , days_since_prior_discharge\\n    , prior_stay_case_id\\n    , is_a_30d_readmit\\n    , case\\n        when days_until_next_discharge <= 30 then 1 \\n        else 0 \\n      end as is_followed_by_a_30d_readmit\\n    , paid_amt_case\\nFROM\\n(\\n\\tSELECT \\n    \\t  A.case_id\\n        , A.adm_dt\\n        , A.dis_dt\\n        , A.a_dis_dt -- spot check\\n        , B.dis_dt as b_dis_dt -- spot check\\n        , A.cin_no\\n        , A.a_cin_no\\n        , B.cin_no as b_cin_no -- spot check\\n        , A.member_no\\n        , A.case_dx1, A.case_dx2, A.case_dx3, A.case_dx4, A.case_dx5, A.case_dx6, A.case_dx7, A.case_dx8, A.case_dx9, A.case_dx10\\n        , A.case_dx11, A.case_dx12, A.case_dx13, A.case_dx14, A.case_dx15, A.case_dx16, A.case_dx17, A.case_dx18, A.case_dx19, A.case_dx20 \\n        , A.case_pr1, A.case_pr2, A.case_pr3, A.case_pr4, A.case_pr5, A.case_pr6, A.case_pr7, A.case_pr8, A.case_pr9, A.case_pr10\\n        , A.severity\\n        , A.aprdrg\\n        , A.dis_status\\n        , A.provider\\n        , A.cur_pcp\\n        , A.cur_site_no\\n        , A.product_code\\n        , A.segment\\n        , A.yearmth\\n        , A.source_table\\n        , A.stay_interval\\n        , A.paid_amt_case\\n        , A.rownumber\\n        , A.days_since_prior_discharge\\n        , A.prior_stay_case_id\\n        , A.is_a_30d_readmit\\n    \\t, CASE\\n        \\t\\tWHEN A.member_no = B.member_no THEN ABS(DATEDIFF(A.dis_dt, B.adm_dt))\\n        \\t\\tELSE NULL\\n    \\t    END AS days_until_next_discharge\\n    \\t, case\\n        \\t    when A.member_no = B.member_no then B.case_id\\n        \\t    else null\\n        \\tend as subsequent_stay_case_id\\n    FROM NATHALIE.njb_A AS A LEFT JOIN NATHALIE.njb_labeled_as_readmits AS B ON A.rownumber = B.rownumber - 1 -- A is earlier than B\\n) AS S\\n;\\n\\n--because you kept as main case data from table 'A', which had a dummry rownumber = 1, you need to shear it off now from table njb_labeled_outcomes. \\n--!!! I cannot find that row I need to delete. TK misunderstanding logic here. Potential problem limited to 1 row. \\n/*\\nselect * from \\n--delete from\\nnjb_labeled_outcomes\\nwhere adm_dt = '1900-01-01'\\n;\\n*/\\n\\n\\n--spot check: ALL GOOD\\n/*\\nselect dis_dt, a_dis_dt, b_dis_dt, cin_no, a_cin_no, b_cin_no, is_a_30d_readmit, is_followed_by_a_30d_readmit\\nfrom nathalie.njb_labeled_outcomes\\nlimit 100\\n;\\n*/\\n\\n\\n/*\\nBRING IN THE DEMOGRAPHICS\\n*/\\n\\n/*\\n    adm_dt\\n    , dis_dt\\n    , A.cin_no\\n    , A.member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , days_since_prior_discharge\\n    , case_id\\n    , prior_stay_case_id\\n    , 30d_readmit\\n    , paid_amt_case\\n    , dob\\n    , abs(datediff(dob, adm_dt)) as adm_age\\n    , gender\\n    , language_written_code\\n    , ethnicity_code\\n    , zip_code\\n    , zip4\\n    , deathdate\\n*/\\n\\n/*TK NOTE THAT THE HOA.MEMBERS TABLE IS POORLY POPULATED. GET SOURCE FROM SOMEWHERE ELSE */\\n\\ncreate table nathalie.njb_demographics_added\\nas\\nselect \\n    case_id\\n    , adm_dt\\n    , dis_dt\\n    , A.cin_no\\n    , A.member_no\\n    , case_dx1, case_dx2, case_dx3, case_dx4, case_dx5, case_dx6, case_dx7, case_dx8, case_dx9, case_dx10\\n    , case_dx11, case_dx12, case_dx13, case_dx14, case_dx15, case_dx16, case_dx17, case_dx18, case_dx19, case_dx20 \\n    , case_pr1, case_pr2, case_pr3, case_pr4, case_pr5, case_pr6, case_pr7, case_pr8, case_pr9, case_pr10\\n    , severity\\n    , aprdrg\\n    , dis_status\\n    , provider\\n    , cur_pcp\\n    , cur_site_no\\n    , A.product_code\\n    , segment\\n    , yearmth\\n    , source_table\\n    , stay_interval\\n    , days_since_prior_discharge\\n    , prior_stay_case_id\\n    , is_a_30d_readmit\\n    , is_followed_by_a_30d_readmit\\n    , paid_amt_case\\n    , dob\\n    , abs(datediff(dob, adm_dt)) as adm_age\\n    , gender\\n    , language_written_code\\n    , ethnicity_code\\n    , zip_code\\n    , zip4\\n    , deathdate\\nfrom nathalie.njb_labeled_outcomes as A left join hoap.members as B on A.cin_no = B.cin_no\\n;\\n\\n\\n/*\\nLABEL THE LOBs and ENGINEER NEW NAMES (concatenate 10 + segment)\\n*/\\n/*Documentation*/\\n                    --FROM HOA DICTIONARY\\n                    IF\\n                    (HEADER_BP_CODE ='COMM'\\n                    AND PRODUCT_CODE='10')\\n                    THEN BP_CODE ='MCLA';\\n                    /*'COMMUNITY' OLD\\n                    RX VENDOR IN2011*/\\n                    ELSE IF (HEADER_BP_CODE\\n                    ='MEDI' AND\\n                    PRODUCT_CODE='10') THEN\\n                    BP_CODE ='MCLA';\\n                    /*'MEDIMPACT' OLD\\n                    RX VENDOR IN2014*/\\n                    ELSE IF (HEADER_BP_CODE\\n                    ='NAVI' AND\\n                    PRODUCT_CODE='10') THEN\\n                    BP_CODE ='MCLA';\\n                    /*'NAVI' NEW RX\\n                    VENDOR IN2015*/\\n                    ELSE IF (HEADER_BP_CODE\\n                    ='TRAN' AND\\n                    PRODUCT_CODE='10') THEN\\n                    BP_CODE ='MCLA';\\n                    /*'TRAN' NEW\\n                    HEADER BP CODE IN2017*/\\n                    ELSE IF (HEADER_BP_CODE\\n                    ='MHC' AND\\n                    PRODUCT_CODE='10') THEN\\n                    BP_CODE ='MCLA';\\n                    /*'MHC' NEW\\n                    HEADER BP CODE IN2017*/\\n                    ELSE IF (\\n                    PRODUCT_CODE='20\\n                    ') THEN BP_CODE ='HFP';\\n                    ELSE IF (\\n                    PRODUCT_CODE='40\\n                    ') THEN BP_CODE ='IHSS';\\n                    ELSE IF (\\n                    PRODUCT_CODE='60\\n                    ') THEN BP_CODE ='HKID';\\n                    ELSE IF (\\n                    PRODUCT_CODE='70\\n                    ') THEN BP_CODE ='SNP';\\n                    ELSE IF (\\n                    PRODUCT_CODE='80\\n                    ') THEN BP_CODE ='CMC';\\n                    ELSE IF (\\n                    PRODUCT_CODE='90\\n                    ') THEN BP_CODE ='HBEX';\\n                    ELSE BP_CODE =\\n                    HEADER_BP_CODE;\\n\\n                    /*\\n                    Product_codes\\n                    10 = Medi-Cal\\n                    20 = Healthy Family Plan\\n                    40 = PASC-SEIU: Personal Assistance Services Counsel-Services Employees International Union /IHSS, In-Home Support Services\\n                    60 = Healthy Kids\\n                    70 = Dual Eligible Special Needs Plan\\n                    80 = Cal-Medi Connect\\n                    90 = LA Care Covered/Health Benefits Exchange\\n                    -1 = Other\\n                    */\\n\\n\\n--TK Need to apply labels to the dataset here for easier export to Excel & presentation of descriptive statistics\\n\\n\\n/*\\nCLEAN UP\\n*/\\nCREATE TABLE NJB_ANALYTIC_SET AS\\nSELECT * FROM NATHALIE.NJB_DEMOGRAPHICS_ADDED;\\n\\nDROP TABLE NATHALIE.NJB_A;\\nDROP TABLE NATHALIE.njb_demographics_added;\\nDROP TABLE NATHALIE.NJB_LABELED_AS_READMITS;\\nDROP TABLE NATHALIE.NJB_LABELED_OUTCOMES;\\nDROP TABLE NATHALIE.NJB_TRANSFERS_ABSORBED;\\n\\n\\n/*\\nANALYSES\\nBY LOB\\ncount of admits, \\ncount of readmits, \\ntotal cost admits\\ntotal cost of readmits\\n[note here that what I cannot capture is opportunity for intervention. Readmit will happen any way bc of illness type; \\nsee as added source of information maybe analyses of success in applying TOC --> do such analyses exist contrasting dif. Dx?]\\n*/\\n\\n/*\\nTABULATE BY POPULATION and BY WHETHER IS A 1st/INDEX ADMIT (without previous admit within 30 days) vs. IS A READMIT\\n--look at counts and cost; plan on exclusing ENC / table 3 data where cost is null\\n*/\\n\\nselect \\n    product_code --this ...\\n    , segment --...and this can be combined by case in order to produce LOBs. See code excerpts above (RE: \\\"product_codes\\\"; offset from Left)for guidance. \\n    , source_table -- confirms that costs are only available where ENC / table 3 was *not* a source. \\n    , is_a_30d_readmit\\n    , count(*)\\n    , sum(paid_amt_case)\\nfrom nathalie.njb_analytic_set\\n--where adm_age > 17 --TK filter is needed, but data field is poorly populated and reduces counts too much. Need to find alternative DOB source. \\n--and adm_age < 65\\ngroup by product_code, segment, source_table, is_a_30d_readmit\\norder by product_code, segment, source_table, is_a_30d_readmit\\n;\\n\\n\\n/*\\nTABULATE BY POPULATION and BY WHETHER ADMISSION WOULD VS. WOULD NOT BE FOLLOWED BY READMITSSION WITHIN 30 DAYS\\n--look at counts alone; include ENC all the way.\\n*/\\n\\nselect \\n    product_code --this ...\\n    , segment --...and this can be combined by case in order to produce LOBs. See code excerpts above (RE: \\\"product_codes\\\"; offset from Left)for guidance. \\n    , is_followed_by_a_30d_readmit\\n    , count(*)\\nfrom nathalie.NJB_ANALYTIC_SET\\n--where adm_age > 17 --TK filter is needed, but data field is poorly populated and reduces counts too much. Need to find alternative DOB source. \\n--and adm_age < 65\\ngroup by product_code, segment, is_followed_by_a_30d_readmit\\norder by product_code, segment, is_followed_by_a_30d_readmit\\n;\\n\\n\\n\\n\\n\\n/*\\nREMAINING ISSUES\\n*/\\n\\n--TK2 to address H vs SNF --> how did you separate these & are you sure you did it correctly? -- TKTK Hospital (whatever is there, include counts) --'provider' but verify that this captures the hospitals. \\n--TK3 bring in DOB, DOD and other demographics -- SCREENING: death date -- SCREENING: birth date. But Members' data are poorly populated. Find in a different table. \\n--TK4 Remove conditions according to HEDIS value sets. \\n--TK5 filter to 1 year analysis\\n\\n--TK6 contrast to Yonsu's data for 1 month. Look over his script again to make sure you catch everything. Eg how does his script handle costs?\\n--TK7 to address last row: you are loosing the last row each iteration. BRING IT BACK! --TK !!! pad the 1st and last rows of 2 versions of NATHALIE.NJB_[input name]. This will help with the next step where the tables are joined by an offset row number.\\n\\n--TK8 breakdown admit/readmit by Dx group (need to discover best grouping system)\\n--TK9 add descriptive labels to product lines / lines of business\\n\\n/*\\ncandidate predictor sets\\n*/\\n\\n-- LACE: engineer length of stay; acuity of admission = severity; comorbidities; emergency department visits\", \"statusForButtons\": \"executed\", \"showLogs\": false, \"variableNames\": [], \"associatedDocumentUuid\": null, \"isResultSettingsVisible\": false, \"chartLimit\": null, \"aceErrorsHolder\": [], \"chartType\": \"bars\", \"isFetchingData\": false, \"name\": \"\", \"statementTypes\": [\"text\", \"file\"], \"is_redacted\": false, \"currentQueryTab\": \"queryResults\", \"chartScope\": \"world\", \"result\": {\"logs\": \"\", \"isMetaFilterVisible\": false, \"meta\": [], \"logLines\": 1, \"id\": \"106a4b3e-049c-5c19-c217-0e7fd4e7e121\", \"statement_id\": 0, \"statements_count\": 1, \"rows\": 24, \"hasSomeResults\": true, \"filteredMetaChecked\": true, \"hasMore\": false, \"filteredMeta\": [{\"comment\": null, \"checked\": true, \"name\": \"product_code\", \"originalIndex\": 1, \"cssClass\": \"sort-string\", \"type\": \"STRING_TYPE\"}, {\"comment\": null, \"checked\": true, \"name\": \"segment\", \"originalIndex\": 2, \"cssClass\": \"sort-string\", \"type\": \"STRING_TYPE\"}, {\"comment\": null, \"checked\": true, \"name\": \"is_followed_by_a_30d_readmit\", \"originalIndex\": 3, \"cssClass\": \"sort-numeric\", \"type\": \"TINYINT_TYPE\"}, {\"comment\": null, \"checked\": true, \"name\": \"count(*)\", \"originalIndex\": 4, \"cssClass\": \"sort-numeric\", \"type\": \"BIGINT_TYPE\"}], \"type\": \"table\", \"handle\": {\"log_context\": null, \"statements_count\": 1, \"end\": {\"column\": 60, \"row\": 9}, \"statement_id\": 0, \"has_more_statements\": false, \"start\": {\"column\": 0, \"row\": 0}, \"secret\": \"ovNgJAXLRDwAAAAAbJph7g==\\n\", \"has_result_set\": true, \"session_guid\": \"3tDbAX3rSUeX4FLQ0zSXAw==\\n\", \"statement\": \"select \\n    product_code --this ...\\n    , segment --...and this can be combined by case in order to produce LOBs. See code excerpts above (RE: \\\"product_codes\\\"; offset from Left)for guidance. \\n    , is_followed_by_a_30d_readmit\\n    , count(*)\\nfrom nathalie.NJB_ANALYTIC_SET\\n--where adm_age > 17 --TK filter is needed, but data field is poorly populated and reduces counts too much. Need to find alternative DOB source. \\n--and adm_age < 65\\ngroup by product_code, segment, is_followed_by_a_30d_readmit\\norder by product_code, segment, is_followed_by_a_30d_readmit\", \"operation_type\": 0, \"modified_row_count\": null, \"guid\": \"ovNgJAXLRDwAAAAAbJph7g==\\n\", \"previous_statement_hash\": \"e797bc90193b49ba2a90938d37154c99d7f3708016a4053bc09834fd\"}, \"metaFilter\": \"\", \"explanation\": \"\", \"statement_range\": {\"start\": {\"column\": 0, \"row\": 0}, \"end\": {\"column\": 0, \"row\": 0}}, \"startTime\": \"2018-04-17T18:31:04.059Z\", \"data\": [], \"executionTime\": 3562, \"fetchedOnce\": false, \"hasResultset\": true, \"endTime\": \"2018-04-17T18:31:07.621Z\"}, \"ddlNotification\": 0.10294802843122075, \"errors\": [], \"chartMapHeat\": null, \"compatibilitySourcePlatforms\": [{\"name\": \"Teradata\", \"value\": \"teradata\"}, {\"name\": \"Oracle\", \"value\": \"oracle\"}, {\"name\": \"Netezza\", \"value\": \"netezza\"}, {\"name\": \"Impala\", \"value\": \"impala\"}, {\"name\": \"Hive\", \"value\": \"hive\"}, {\"name\": \"DB2\", \"value\": \"db2\"}, {\"name\": \"Greenplum\", \"value\": \"greenplum\"}, {\"name\": \"MySQL\", \"value\": \"mysql\"}, {\"name\": \"PostgreSQL\", \"value\": \"postgresql\"}, {\"name\": \"Informix\", \"value\": \"informix\"}, {\"name\": \"SQL Server\", \"value\": \"sqlserver\"}, {\"name\": \"Sybase\", \"value\": \"sybase\"}, {\"name\": \"Access\", \"value\": \"access\"}, {\"name\": \"Firebird\", \"value\": \"firebird\"}, {\"name\": \"ANSISQL\", \"value\": \"ansisql\"}, {\"name\": \"Generic\", \"value\": \"generic\"}], \"progress\": 0, \"showOptimizer\": false, \"compatibilityTargetPlatform\": \"impala\", \"jobs\": [], \"statementType\": \"text\", \"variableValues\": {}, \"isCanceling\": false, \"queriesTotalPages\": 1, \"formatEnabled\": true, \"properties\": {\"settings\": []}, \"aceErrors\": [], \"externalStatementLoaded\": false, \"chartScatterSize\": null, \"chartYSingle\": null, \"isSqlDialect\": true, \"statementPath\": \"\", \"showLongOperationWarning\": false, \"chartX\": \"product_code\", \"lastExecuted\": 1523989864050, \"variables\": [], \"showChart\": false, \"compatibilitySourcePlatform\": \"impala\", \"showGrid\": true, \"pinnedContextTabs\": [], \"viewSettings\": {\"sqlDialect\": true, \"placeHolder\": \"Example: SELECT * FROM tablename, or press CTRL + space\"}, \"statementsList\": [\"\\n                    ELSE IF (\\n                    PRODUCT_CODE='80\\n                    ') THEN BP_CODE ='CMC';\", \"\\n                    ELSE IF (\\n                    PRODUCT_CODE='90\\n                    ') THEN BP_CODE ='HBEX';\", \"\\n                    ELSE BP_CODE =\\n                    HEADER_BP_CODE;\", \"\\n\\n                    /*\\n                    Product_codes\\n                    10 = Medi-Cal\\n                    20 = Healthy Family Plan\\n                    40 = PASC-SEIU: Personal Assistance Services Counsel-Services Employees International Union /IHSS, In-Home Support Services\\n                    60 = Healthy Kids\\n                    70 = Dual Eligible Special Needs Plan\\n                    80 = Cal-Medi Connect\\n                    90 = LA Care Covered/Health Benefits Exchange\\n                    -1 = Other\\n                    */\\n\\n\\n--TK Need to apply labels to the dataset here for easier export to Excel & presentation of descriptive statistics\\n\\n\\n/*\\nCLEAN UP\\n*/\\nCREATE TABLE NJB_ANALYTIC_SET AS\\nSELECT * FROM NATHALIE.NJB_DEMOGRAPHICS_ADDED;\", \"\\n\\nDROP TABLE NATHALIE.NJB_A;\", \"\\nDROP TABLE NATHALIE.njb_demographics_added;\", \"\\nDROP TABLE NATHALIE.NJB_LABELED_AS_READMITS;\", \"\\nDROP TABLE NATHALIE.NJB_LABELED_OUTCOMES;\", \"\\nDROP TABLE NATHALIE.NJB_TRANSFERS_ABSORBED;\", \"\\n\\n\\n/*\\nANALYSES\\nBY LOB\\ncount of admits, \\ncount of readmits, \\ntotal cost admits\\ntotal cost of readmits\\n[note here that what I cannot capture is opportunity for intervention. Readmit will happen any way bc of illness type; \\nsee as added source of information maybe analyses of success in applying TOC --> do such analyses exist contrasting dif. Dx?]\\n*/\\n\\n/*\\nTABULATE BY POPULATION and BY WHETHER IS A 1st/INDEX ADMIT (without previous admit within 30 days) vs. IS A READMIT\\n--look at counts and cost; plan on exclusing ENC / table 3 data where cost is null\\n*/\\n\\nselect \\n    product_code --this ...\\n    , segment --...and this can be combined by case in order to produce LOBs. See code excerpts above (RE: \\\"product_codes\\\"; offset from Left)for guidance. \\n    , source_table -- confirms that costs are only available where ENC / table 3 was *not* a source. \\n    , is_a_30d_readmit\\n    , count(*)\\n    , sum(paid_amt_case)\\nfrom nathalie.njb_analytic_set\\n--where adm_age > 17 --TK filter is needed, but data field is poorly populated and reduces counts too much. Need to find alternative DOB source. \\n--and adm_age < 65\\ngroup by product_code, segment, source_table, is_a_30d_readmit\\norder by product_code, segment, source_table, is_a_30d_readmit\\n;\", \"\\n\\n\\n/*\\nTABULATE BY POPULATION and BY WHETHER ADMISSION WOULD VS. WOULD NOT BE FOLLOWED BY READMITSSION WITHIN 30 DAYS\\n--look at counts alone; include ENC all the way.\\n*/\\n\\nselect \\n    product_code --this ...\\n    , segment --...and this can be combined by case in order to produce LOBs. See code excerpts above (RE: \\\"product_codes\\\"; offset from Left)for guidance. \\n    , is_followed_by_a_30d_readmit\\n    , count(*)\\nfrom nathalie.NJB_ANALYTIC_SET\\n--where adm_age > 17 --TK filter is needed, but data field is poorly populated and reduces counts too much. Need to find alternative DOB source. \\n--and adm_age < 65\\ngroup by product_code, segment, is_followed_by_a_30d_readmit\\norder by product_code, segment, is_followed_by_a_30d_readmit\\n;\", \"\\n\\n\\n\\n\\n\\n/*\\nREMAINING ISSUES\\n*/\\n\\n--TK2 to address H vs SNF --> how did you separate these & are you sure you did it correctly? -- TKTK Hospital (whatever is there, include counts) --'provider' but verify that this captures the hospitals. \\n--TK3 bring in DOB, DOD and other demographics -- SCREENING: death date -- SCREENING: birth date. But Members' data are poorly populated. Find in a different table. \\n--TK4 Remove conditions according to HEDIS value sets. \\n--TK5 filter to 1 year analysis\\n\\n--TK6 contrast to Yonsu's data for 1 month. Look over his script again to make sure you catch everything. Eg how does his script handle costs?\\n--TK7 to address last row: you are loosing the last row each iteration. BRING IT BACK! --TK !!! pad the 1st and last rows of 2 versions of NATHALIE.NJB_[input name]. This will help with the next step where the tables are joined by an offset row number.\\n\\n--TK8 breakdown admit/readmit by Dx group (need to discover best grouping system)\\n--TK9 add descriptive labels to product lines / lines of business\\n\\n/*\\ncandidate predictor sets\\n*/\\n\\n-- LACE: engineer length of stay; acuity of admission = severity; comorbidities; emergency department visits\"], \"lastAceSelectionRowOffset\": 875, \"executingBlockingOperation\": null, \"queriesFilterVisible\": false, \"statement\": \"\\n\\n\\n/*\\nTABULATE BY POPULATION and BY WHETHER ADMISSION WOULD VS. WOULD NOT BE FOLLOWED BY READMITSSION WITHIN 30 DAYS\\n--look at counts alone; include ENC all the way.\\n*/\\n\\nselect \\n    product_code --this ...\\n    , segment --...and this can be combined by case in order to produce LOBs. See code excerpts above (RE: \\\"product_codes\\\"; offset from Left)for guidance. \\n    , is_followed_by_a_30d_readmit\\n    , count(*)\\nfrom nathalie.NJB_ANALYTIC_SET\\n--where adm_age > 17 --TK filter is needed, but data field is poorly populated and reduces counts too much. Need to find alternative DOB source. \\n--and adm_age < 65\\ngroup by product_code, segment, is_followed_by_a_30d_readmit\\norder by product_code, segment, is_followed_by_a_30d_readmit\\n;\", \"type\": \"impala\", \"chartSorting\": \"none\", \"previousChartOptions\": {\"chartTimelineType\": \"bar\", \"chartSorting\": \"none\", \"chartLimit\": null, \"chartMapHeat\": null, \"chartX\": \"product_code\", \"chartMapType\": \"marker\", \"chartXPivot\": null, \"chartScatterSize\": null, \"chartScope\": \"world\", \"chartMapLabel\": null, \"chartScatterGroup\": null, \"chartYSingle\": null, \"chartYMulti\": [\"count(*)\"]}, \"aceWarningsHolder\": [], \"resultsKlass\": \"results impala\", \"delayedDDLNotification\": 0.10294802843122075, \"chartTimelineType\": \"bar\", \"compatibilityTargetPlatforms\": [{\"name\": \"Impala\", \"value\": \"impala\"}, {\"name\": \"Hive\", \"value\": \"hive\"}], \"topRisk\": null, \"hasCurlyBracketParameters\": true, \"chartScatterGroup\": null, \"settingsVisible\": false, \"errorsKlass\": \"results impala alert alert-error\", \"aceWarnings\": [], \"compatibilityCheckRunning\": false, \"isLoading\": false, \"loadingQueries\": false, \"hasDataForChart\": true, \"id\": \"a6d5440f-625f-4591-5e35-21322280e31b\", \"aceSize\": 100, \"chartData\": [], \"queriesHasErrors\": false, \"chartMapLabel\": null, \"status\": \"expired\", \"suggestion\": \"\", \"chartMapType\": \"marker\", \"queriesFilter\": \"\", \"queriesCurrentPage\": 1, \"isBatchable\": true, \"chartYMulti\": [\"count(*)\"], \"dbSelectionVisible\": false, \"database\": \"nathalie\", \"hasSuggestion\": null, \"chartXPivot\": null, \"checkStatusTimeout\": null}], \"isHistory\": false, \"type\": \"query-impala\", \"historyFilter\": \"\", \"description\": \"readmission rate and cost subpopulation contrast\", \"sessions\": [{\"http_addr\": \"http://dsdata1.lacare.org:25000\", \"type\": \"impala\", \"properties\": [{\"multiple\": true, \"defaultValue\": [], \"value\": [], \"nice_name\": \"Settings\", \"key\": \"settings\", \"help_text\": \"Impala configuration properties.\", \"type\": \"settings\", \"options\": [\"debug_action\", \"explain_level\", \"mem_limit\", \"optimize_partition_key_scans\", \"query_timeout_s\", \"request_pool\"]}], \"id\": 4921}], \"updateHistoryFailed\": false, \"presentationSnippets\": {}, \"isBatchable\": true, \"selectedSnippet\": \"impala\", \"coordinatorUuid\": null, \"name\": \"read_ratecost_by_subpopulation\", \"isManaged\": false, \"loadingScheduler\": false, \"viewSchedulerId\": \"\", \"isSaved\": true, \"historyCurrentPage\": 1, \"creatingSessionLocks\": [], \"directoryUuid\": \"\", \"parentSavedQueryUuid\": \"86dc0fd4-4e43-2a54-36cf-70c4b1b42332\", \"dependentsCoordinator\": []}", 
    "is_trashed": false, 
    "name": "read_ratecost_by_subpopulation"
  }
}
]
